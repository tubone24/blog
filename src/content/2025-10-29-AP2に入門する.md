---
slug: 2025-10-29/AP2に入門する
title: "AP2に入門する"
date: 2025-10-29T04:00:20+0000
description: AP2(Agent Payments Protocol)に入門してみます。
tags:
  - fixme
headerImage: https://i.imgur.com/QmIHfeR.jpg
templateKey: blog-post
---

お久しぶりです。

## Table of Contents

```toc

```

## すごいせっかちな人向けに

デモアプリを作ってみました。

![demo](https://i.imgur.com/4umwhpw.gif)

Docker ComposeでAP2を語るうえで必要なサービスが立ち上がります。

## AP2に入門してみたくなった。

突然ですが、育休を取っています。なので、なにか新しい技術を学んでおかないと復帰後不安で押しつぶされそうなので、重い腰をあげてAP2([Agent Payments Protocol](https://ap2-protocol.org/))に入門しようと思います。

どうにも生成AIの世界は謎のプロトコルが次々とでてくる...。この前MCPに入門したと思ったら、A2A、そしてAP2...。困りましたね。

AP2とは、Googleによると、

> 主要な決済企業やテクノロジー企業と共同で開発されたオープン プロトコルで、プラットフォームをまたいでエージェント主導の決済を安全に開始、実行するもの

とのことで、要はAIエージェントを絡めたお買い物、決済を考えたときに起こり得るさまざまな不都合や問題をうまい具合に解決する仕組みです。

そもそもAIエージェントを用いたお買い物で起こり得る問題ってなんでしょうか。

## まず人間の買い物を想像してみましょう

AP2を考える前に、まずは人間の買い物を想像してみましょう。

![a](https://i.imgur.com/hvUOvHi.png)

Aさんは「かわいい犬のグッズ」がほしいな〜と思っているとします。ちなみに「『かわいい犬のグッズ』がほしいな〜」という気持ち(意図)のことをAP2では、Intentといいます。

しばらく歩いていると、「むぎぼーショップ」というかわいい柴犬をモチーフにしたお店を発見しました。入ってみましょう。

「むぎぼーショップ」は店員さんがとても優秀で、お客さまの気持ちによりそった最適な商品を提示してくれるお店でした。細かい要望を伝えると、在庫を確認した後予算内でいくつか商品をピックアップしてくれました。（おすすめセットのリストを作ってくれました）

![a](https://i.imgur.com/E2feFkd.png)

Aさんもおすすめセットに納得したようで支払い手続きに進みます。お店に設置されているxxPayの端末を使ってお会計を済ませます。商品と領収書をもらってお買い物完了です。

![a](https://i.imgur.com/dXUyJlg.png)

以上が人間のお買い物でした。ポイントとしてAP2で想定されるお買い物は、スーパーなどの[セルフサービス方式](https://md-next.jp/yougo/%e3%82%bb%e3%83%ab%e3%83%95%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9)ではなく、[対面販売](https://md-next.jp/yougo/%E5%AF%BE%E9%9D%A2%E8%B2%A9%E5%A3%B2)を想定しています。

なので、買い物カゴに商品を入れてくれるのは店員さんで、その買い物カゴを確認してOKを出す感じです。

![](https://i.imgur.com/f2gUFXs.png)

生成AIで作成したこの画像のように、商品棚から店員さんがピックアップしてくれるようなスタイルです。

この流れをAIエージェントに登場させることを考えていきましょう。

## その買い物、誰が間違えた...?

では、この流れでお買い物の一部をAIエージェントに任せることを想定してみます。

例えば、ユーザーの代わりにお買い物をするお買い物エージェント(Shopping Agent、以降SA)とお店の店員さんの代わりに業務をするお店エージェント(Merchant Agent、以降MA)が追加された構図を考えていきます。

### ハルシネーション

まず思い浮かぶのは、AIエージェントのハルシネーション問題です。あたかも知ったように誤った情報をべらべら話すあの現象です。

お買い物というシチュエーションでこれが起きると大変です。しかも、考えられるミスのパターンが多いのも特徴です。

一番想像しやすいのは、ユーザーの意図（Intent）をSAが間違って理解してMAに伝えてしまうパターンです。伝言ゲーム的に間違った意図のもと購入が進められてしまいます。安い買い物ならまだしも、数百万の決済を勝手にやられては困ります。

![ia](https://i.imgur.com/P3B8dhg.png)

他にもMAが意図を間違えて解釈するケースもありそうです。

![aa](https://i.imgur.com/5XVBhIa.png)

さらに複雑なケースを想定すると、ユーザーの意図は正しく伝えられても、お店側の都合、例えばお得意さんしか売ってはいけない商品を売ってしまう、というMA側のコンテキスト不足によるミスもありそうです。

![aaa](https://i.imgur.com/E5N4Gjl.png)

### もっと悩ましいパターン

もっと悩ましいパターンも考えられます。例えばAさんが、AIエージェントには「かわいい犬のグッズがほしい」とお願いしておきながら、その意思を途中で変えてしまう、というものです。

心変わりしたり、いたずらだったり、勘違いだったり色々理由はあると思いますが、ユーザーから「実はかわいい猫のグッズがほしかった」と言われたら誰が責任を取るべきかわからなくなってしまうのも問題です。

![aaa](https://i.imgur.com/aL1N9Yl.png)

また、ユーザーになりすましてAIエージェントに購入の指示をされたりした場合にも同様の問題が起きてしまう可能性もあります。（なりすまし問題）



## AIエージェントが情報を知りすぎる問題

また、少し話の毛色は変わりますが、AIエージェント（SA）がユーザーの代わりにお買い物をする場合、ユーザーのお財布を勝手に使えてしまったりすることも問題です。

クレジットカード決済する場合を想定すると、カードの番号の他、有効期限や、CVC(Card Validation Code、カード裏面にある3桁くらいのコード)を知ってしまうことになります。これでは、万が一のときにカード情報が漏洩したり、AIエージェントが暴走して闇雲に高級品を買いまくったりする危険もありそうです。

加えて、AIエージェント（MA）がお店の決済システムに密結合になってしまうこともシステム保守観点で危うさがあります。

![aa](https://i.imgur.com/W4SrXsP.png)

## AP2ではどんな仕組みでこれらを解決しているのか

AP2ではこれらの課題を高度な暗号技術を組み合わせたデジタル署名をA2A(Agent2Agent)の通信にうまく拡張することで解決します。

### シーケンス

まずは、難しい用語抜きでわかりやすい（？）紙芝居をお見せし、それらで出てくる具体的な概念から用語を抑えたほうがきっとわかりやすいと確信したので、しばし紙芝居にお付き合いください。

（説明の都合で各ステップの順番を入れ替えている箇所があります。また、現時点シーケンスが公開されている[Illustrative Transaction Flow](https://ap2-protocol.org/specification/#71-illustrative-transaction-flow)を参考に作成していますが仕様がはっきりしない箇所もあり推測も多分に含まれます。ご了承ください。）

![a](https://i.imgur.com/lKKSQnI.png)

まず、Aさんは「かわいい犬のグッズがほしい」「5000円以内」など具体的な購入意図をお買い物エージェント（Shopping Agent、SA）に指示します。すると、SAはその購入意図を汲み取ってお買い物を始めます。

実際にお買い物に移る前に、ユーザーと購入意図を委任状にしたIntent　Mandate、つまり「これから私AはSAに『かわいい犬のグッズを5000円以内』で購入することを委任します。」と委任状を取り交わします。Intent Mandateについては後ほど詳しくお話します。

と同時に、「むぎぼーショップ」のお店エージェント（Merchant Agent、MA）がSAに対して自分のお店の紹介も兼ねて名刺交換します。

A2Aに詳しい方ならピンとくると思いますが、A2AにおけるAgent Cardで自身の取り扱い状況やAP2に対応した購入体験ができますよ、ということを伝えてます。

![c](https://i.imgur.com/0KxrKpp.png)

次に、SAはMAと名刺交換した結果をもとにむぎぼーショップと取引をスタートすることを決めました。A2AのMessageを用いて、SA-MAのエージェント間通信を実施します。

ここでユーザーと取り交わしたIntent Mandateを送ることで、SAがユーザーの意図を確かに汲んだ購入をしていることをMAに示しつつ、目的の商品カートを作ってもらうことをお願いするわけです。

MAはユーザーのIntentを受けて、どんな商品セットがよいか検討を始めます。お店側（Merchant）の在庫状況や各商品の金額、説明などを見極め、ユーザーにぴったりな商品が入った商品カートを作成しにいきます。

![d](https://i.imgur.com/QVFkhfa.png)

さて、MAはついにユーザーにぴったりな商品の入った商品カートを作成しました。この商品カートの作成は本来はお店側(Merchant)が作るべきものですが、MAがお店の代わりに作成しているものですので、委任状の形でお店側の販売行為を委任していることを示す必要があります。

そこで、MAは商品カートの委任状（Cart Mandate）を作成し、お店側に確認と確かに確認したという署名をお店がつけます。

![b](https://i.imgur.com/wPZgNbR.png)

お店とMAの間での委任状の取り交わしが無事完了したら、その委任状（Cart Mandate）をSAに送信します。この商品カートをSAがユーザーに提示しながら実際の購入まで進めていくわけです。

![h](https://i.imgur.com/qNfLrKJ.png)

AさんはSAから提示された商品カートの委任状（Cart Mandate）に基づき、自身が購入する商品カートを確定させます。（Cart MandateはA2A Artifactsの形で複数提示もできるため、複数の候補から選択するUIも想定されうる）

確定した商品カートの委任状について、 ~「確かにAが確定しましたよ」という意味合いで、ユーザーが署名をつけます。（実際にはDevice Attestationの動作が入りますが、Payment Mandateのところで説明します）~　ユーザーに確認を求めます。

（実装して気がついたのですが、Cart Mandateにはユーザー署名は構造上つけることはできません。なぜならユーザー署名を付けてしまうと、JSON構造が壊れてしまい、その手前のMerchantの署名が壊れてしまうためです。）

![i](https://i.imgur.com/rXcmmUi.png)

同時に、SAはユーザーが商品を購入するにあたっての支払い方法についても確認する必要があります。AP2では、Credential Provider(CP)という謎の概念が出てきます。

公式ドキュメントによると

> 3 The User’s Credentials Provider (CP): A specialized entity responsible for the secure management and execution of payments credentials (e.g. a digital Wallet). It holds knowledge of the User's available payment methods, gets user consent (if deemed necessary) to share credentials with the SA, selects the optimal payment method based on user preferences and transaction context, and handles payment scenarios like errors, declines and transaction challenges gracefully.

とあり、CPはユーザーの支払いおよびID資格情報を安全に管理・実行する専門的なエンティティの意味ですが、ようはデジタルウォレットと思っていただいて良さそうです。イメージとしてはGoogle PayやApple Payのようなスマートフォンからクレジットカードが使えるサービスが近いです。

のちのちユーザーに支払い方法を確認するため、CPに紐づく支払い方法を確認します。現状の仕様ではクレジットカードやデビットカードが選択可能だそうですが、将来的にはSuicaのようなサービスにも対応可能とのことです。

ここでポイントなのは、SAは支払い情報をユーザーに選択させるための最低限の情報（たとえばクレジットカードの下4桁とか）のみ受け取ります。

![f](https://i.imgur.com/Gyc2QU9.png)

では支払いに移りましょう。SAは先程CPから受け取った支払い情報からユーザーが利用する支払い方法を確定させます。ユーザーが支払いに利用するカードを確定させたら、CPにそのカードのトークン(支払い方法トークン、payment method token)を発行依頼します。

このトークンは、一時的な支払い利用の可能なカード情報となります。ただし、トークンには一切支払いに必要な情報(PCIデータ、カード番号とか)は含まれません。CPにはトークンと実情報のマッピングが存在するため、CPを経由することで支払いが可能となるわけです。またトークンはしばしば期限付きの支払能力のある代替通貨となる場合が多いので発行は実際のクレジットカードの決済ネットワークと連携して行われる形です。

支払い方法トークンが取得できたらSAは支払い委任状（Payment Mandate）を作成します。これは商品の細かな明細を含まない合計金額や支払い方法を明記した簡素な委任状となります。まず、ユーザーに「私SAはAさんに変わってこの委任状の通り支払いしますよ」という委任状をSAは提示し、ユーザーから署名をもらうことでユーザー意思を確定させます。

このとき、device attestationの動きが入ります。これはトランザクションの信頼性と否認不可能性を高めるためとされ、TPM、Secure Enclaveなどを用いて、ハードウェアに裏打ちされたキーとインセッション認証（生体認証など）を通じて実行されます。こうすることで確実にAさんが承認しましたよ。という血判状になるんですね。

![e](https://i.imgur.com/ATRxVXv.png)

ユーザー署名付き支払い委任状（Payment Mandate）が出来上がったら、MAに送信し、いよいよ支払いに移ります。

ここで重要なのは、支払い処理そのものはMAは実施せず、お店に紐づく支払いエンティティ（Merchant Payment Processor、MPP）が実施します。これは明確な職務分離というAP2の基本概念に従った実装となります。

![g](https://i.imgur.com/2sJ5eqV.png)

支払いが完了したら領収書をMPPが発行し、CPとSAに送信します。SAは領収書を受け取ってユーザーに取引の完了を伝えます。これがAP2で実現される動きです。

お疲れ様でした！

### 委任状（Mandate）

あらためて、AP2を語るうえで欠かせないのが委任状(Mandate)と呼ばれるデジタル署名付きの正式な委任証明の仕組みを再確認しましょう。

詳細はこのあとのコードでの説明で語ることとして、ユーザー・AIエージェント・お店などがそれぞれ持っている秘密鍵を使って委任状のJSONにデジタル署名を行い、その検証を各工程で実施することで、その委任が各エンティティが確実に実施したことを保証してます。デジタル署名を使ってそれぞれのエンティティが内容に承認、署名する仕組みがAP2の一番面白いところと言えるでしょう。

委任状（Mandate）には3種類あり、各シーケンスで必要な情報を送受信します。

#### Intent Mandate

まずはIntent Mandateです。これは、ユーザーの購入意図(Intent)を示すものです。

SAが作成し、ユーザーへ「あなたの購入意図はこうだよね？これでMAに依頼するけどいいかな？」といった具合で確認をとり、確認がとれたらそれをMAに伝えます。

「ユーザーの確認」をとって、と述べましたが、ユーザーの関与の仕方（トランザクションの様式）によってユーザーの署名が必要か署名が不要か変わってきます。トランザクションの様式については後ほど説明します。

今回のデモアプリは、シーケンスの細かいところまで割れているHuman in presentというトランザクションの様式で作成しているため、より革新的な技術であるHuman not in presentはあまりわかっていません。もう少し仕様がわかってきたらこちらも試してみたいと思います。

#### Cart Mandate

次にCart Mandateです。これは、MAが作成してきた商品が入ったカートを指します。

この商品カートが「本当に売っていいものなのか」、「本当に買いたいものなのか」をお店側、ユーザー双方に承認を取ることで購入へと進みます。

Cart Mandateにはお店の署名としてCart MandateのJSONをJWTで署名したBase64文字列を付加します。これを検証することで確かにお店がトランザクションに関わっていることを保証できるわけです。

ちなみに、お店側の署名はどのトランザクションでも必要になります。

#### Payment Mandate

最後にPayment Mandateです。これはSAがユーザーに代わって支払いをするうえで必要な委任状でユーザーの署名と支払いに関するトークンが含まれているのが特徴です。

このMandateがあることで、すべての取引についてユーザーが最終合意したことを示すことができます。Cart Mandateと同様に、Payment Mandateにはユーザーの署名としてPayment MandateのJSONをJWTで署名したBase64文字列を付加します。

この取引がエージェントによるものであり、どのような認証プロセスを経たかというのがPayment Mandateを見ることでわかるようになっているのでお店の決済処理システムや決済ネットワークに正しくリスクを含めて伝えることができるのが特徴です。

### トランザクションの様式

AP2には主に２つのトランザクションの様式があります。「Human Present (人間がその場にいる決済)」と「Human Not Present (人間がその場にいない決済)」です。ユーザーの関与の仕方が異なります。

#### Human Present

まず、「Human Present」は、ユーザーがAIエージェントにタスクを委任するものの、**最終的な支払いを承認するためにその場にいる（利用可能である）** シナリオに適用されます。イメージとしては、チャットボットと会話しながら商品を選び、買い物を完了させるような動きです。

この場合、ユーザーの意思を否認不可で証明するべきはCart Mandateになります。なぜなら、商品カートを選んで購入するときにユーザーに最終確認を求めることができるためです。なので、Intent Mandateへのユーザー署名は省略することができます。（おそらく署名してもいいのですが、UIUX的にかなり冗長になるのでこのデモアプリでは避けてます。）

#### Human Not Present

「Human Not Present」は、ユーザーがエージェントにタスクを委任し、ユーザーが不在の状況下でエージェントが決済を自律的に実行することを許可するシナリオに適用されます。

例えば、「価格が100ドルを下回ったらこの靴を買う」のようにあらかじめ購入の条件をSAに伝えておいて、SAがその条件になったらユーザー不在のまま購入手続きを進める、というものです。

この場合、ユーザーの意思を否認不可で証明するべきはIntent Mandateになります。なので、「Human Not Present」ではIntent Mandateにユーザー署名が必須となります。

とはいえ、実はHuman Not Presentの仕様は公式ドキュメントでまだ詳しくでてないので、その後のPayment Mandateはどう扱うのか。もし不都合な購入が進められてしまった場合の紛争解決はどうするのかなどは存じてません。すみません。

## では作ったものを見ていこう

ドキュメントから得られる自分のAP2に関する知識は正直このレベルなので、実際に作りながら細かい挙動や署名の仕組み、A2Aで実際にやり取りされる内容、UIUXなどを深堀りしていこうと思います。

公式ドキュメントでは「Human Not Present」のシーケンスがなかったのでそちらへは対応してません。

### 構成図

![ig](https://i.imgur.com/KbSA2Lp.png)

とても複雑になってしまいましたが、むしろDocker ComposeのYAMLファイルを見たほうがイメージしやすいかもしれません。抜粋したものを見てみましょう。

```yaml
version: "3.8"

services:
  # Init Keys - キーペア初期化（起動時に1回実行）
  init-keys:
  # Init Seeds - シードデータ投入（起動時に1回実行）
  init-seeds:
  # Shopping Agent - ユーザー向けエージェント
  shopping_agent:
  # Shopping Agent MCP - MCPツール（LangGraphノード）
  shopping_agent_mcp:
  # Merchant Agent - 商品検索・CartMandate作成
  merchant_agent:
  # Merchant Agent MCP - MCPツール（LangGraphノード）
  merchant_agent_mcp:
  # Merchant - CartMandate署名
  merchant:
  # Credential Provider 1 - WebAuthn検証・トークン発行
  credential_provider:
  # Credential Provider 2 - WebAuthn検証・トークン発行（複数CP対応）
  credential_provider_2:
  # Payment Processor - 決済処理
  payment_processor:
  # Payment Network - 決済ネットワーク（Agent Token発行）
  payment_network:
  # Frontend - Next.js
  frontend:
  # Meilisearch - 全文検索エンジン（商品検索用）
  meilisearch:
  # Jaeger - 分散トレーシングバックエンド（OpenTelemetry）
  jaeger:
  # Redis - KVストア（一時データ・セッション管理）
  redis:
```

SAとMAがそれぞれいるのと、SAとユーザーを繋ぐフロントエンドがいます。
また、SA、MAがMandateを作ったり、商品検索を実施するためのツールが独立したMCPサーバーとしてDocker Composeのサービスになっており、StreamableHTTPで利用可能な形となっています。

さらにCP、MPPそして決済ネットワークのスタブサービスが立ち上がります。

各エンティティは固有のDBを持ち、SQLiteで実装されています。一時的なKVストアが必要なときは共通のRedisにアクセスしつつ、DBが各エンティティで分けています。
また、商品検索には全文検索エンジンが適しているためMeilisearchを利用します。

さらに、OpenTelemetryのバックエンドとしてJeagerを導入しました。

すべてのサービスが利用する公開鍵、秘密鍵および、DiDは初期化スクリプトで作成されます。

また、LLMOpsの観点で、Langfuseを導入しています。これによりSAやMAのLangGraphのグラフ構築がだいぶ楽になりました。

### 事前準備

まずは、ユーザーを作成するところからやりましょう。このデモアプリではメールアドレス・パスワードでユーザーを作成します。主にSAとの通信で利用されるHTTP Sessionとしての認証情報となります。もうすこしわかりやすく言えば、お買い物チャットボットの認証といえるでしょう。

![a](https://i.imgur.com/lXLFcVy.png)

それとは別にパスキーの登録画面が入ります。これは、asstationのために利用するものです。パスキーはSAに登録されるのではなく、CPにて管理されます。今回は簡易的にSAとの通信に使うフロントエンドにて登録する形となっています。

![img](https://i.imgur.com/1JtKeyr.png)

さらにクレジットカード情報を登録します。これもSAではなく、CPに登録しているのですが同様の理由で同じフロントエンドから実施しています。（なのでSAはからは見えません）

![img](https://i.imgur.com/P0dDkIE.png)

### フロントエンドの概要

フロントエンドは3つの画面で構成されます。 `/chat` `/merchant` `/payment-methods`です。

`/chat`はユーザーとSAのの間のチャットUIを提供します。`/payment-methods`は先程追加したクレジットカードの編集削除や、追加ができる画面です。CPと通信するため本来は別のドメインになるはずです。　`/merchant` は文字通りお店側の管理画面です。商品管理や注文履歴の管理、お店側の署名を手動で行うなどが可能です。

こちらも本来はお店専用のフロントエンドとなるはずです。

早速、`/chat`からチャットをスタートしましょう！

「こんにちは」とかなにか文字を打つとスタートします。

## SAはLangGraph

突然ですが、SAは[LangGraph](https://www.langchain.com/langgraph)と[Docker Model Runner](https://www.docker.com/ja-jp/products/model-runner/)で動かしてます。Docker Model Runnerを使ったのは、Docker Composeですべての環境が手に入る（ローカルLLMなので）のと、育休中で金がないので検証のために気軽にAPIを叩けないためです。（とても金欠、助けてくれ。）

なので、このデモは無料で試せるのです！その代わりローカルLLM（QWEN3）を使うので全体的に動作はもっさりします。気になる方は、別のモデルを利用していただければと思います。

LangGraphのグラフは次のとおりです。

![graph](https://i.imgur.com/guOh2VY.png)

だいぶ長い+直線的なグラフになっていますが、AP2のシナリオはかなり複雑で署名の順番も重要なので紙芝居的に動きます。どこかエラーになるとエラーノードに移動し、「こんにちは」と入力させてリセットさせる必要があります。

このあたりのグラフにもこだわりたいですが、そうすると時間も足りなくなるのでユーザーのインテントを抽出するところだけLLM（青いところ）を利用し、それ以外は固定の文言で動きます。

例えば工夫の余地があるとしたら、MAからカート情報を受け取ったら一度SA側で推論をかけて、結果を精査した後ユーザーに提示、などもできると思います。

### Intent抽出・Intent Mandate骨子作成(collect_intent)

挨拶ノードは説明をスキップしてまず、重要なのはcollet_intentノードです。ユーザーの購入意図を自然言語で受付け、Intent Mandateの骨子を作成する重要なノードです。

購入意図、予算、キーワード、商品カテゴリー、ブランドなどを抽出します。

![aaa](https://i.imgur.com/W3hZl94.png)


これは公式ドキュメントのシーケンス[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)でいうところのStep1〜3となります。

本来であればStep3でComfirmとなっているのでユーザーにポップアップなどで確認を求める必要がありそうですが、AP2のお買い物は署名の要求で絶えずポップアップがでてしまい体験が非常に悪いので、違ったら「違うよ」とチャットに入力してもらうことを想定して専用のポップアップは避けるようにしてます。

動作ログを見ると、次のようにLLMから必要情報が取り出されていることがわかると思います。

```log
ap2_shopping_agent         | [2025-11-01 00:49:37,548] INFO in services.shopping_agent.langgraph_shopping_flow: [route_by_step] Routing decision
ap2_shopping_agent         |   current_step: ask_intent
ap2_shopping_agent         |   user_input: かわいいグッズがほしい。5000円以内
ap2_shopping_agent         |   is_step_up_completion: False

ap2_shopping_agent         | [2025-11-01 00:50:12,592] INFO in services.shopping_agent.langgraph_shopping_flow: [collect_intent_node] LLM result: {'intent': 'かわいいグッズを購入したい', 'max_amount': 5000, 'keywords': ['かわいい', 'グッズ', 'おしゃれ']}

ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:12.593597Z", "level": "INFO", "logger": "agent", "message": "[_create_intent_mandate] Reconstructed intent: かわいいグッズを購入したい。5000円以内", "module": "agent", "function": "_create_intent_mandate", "line": 1733}

ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:12.593977Z", "level": "INFO", "logger": "agent", "message": "[_build_intent_mandate_from_session] Constructed natural_language_description: かわいいグッズを購入したい。5000円以内", "module": "agent", "function": "_build_intent_mandate_from_session", "line": 1812}

ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:12.594677Z", "level": "INFO", "logger": "agent", "message": "[ShoppingAgent] IntentMandate created (AP2-compliant): intent='かわいいグッズを購入したい...', expiry=2025-11-01T01:50:12.593363Z", "module": "agent", "function": "_build_intent_mandate_from_session", "line": 1824}
```

### 配送先の確定(collect_shipping)

AP2で重要なのは、各Mandateのやり取り時に金額を確定させることです。実は配送料が500円かかりました！とすべての購入が終わってから後出しジャンケンされても困ってしまうためです。そこで、配送先の確定はシーケンスの早い段階で実施します。[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)でいうところのStep5に該当します。

もし、SAがすでに配送先の情報を持っていたら、この処理はSA側で実施できるためシーケンス上はOptionalになっています。

![aaa](https://i.imgur.com/DkjncNI.png)

### CPの選択(select_cp)

Optionalにはなりますが、CPを複数選択することができます。イメージとしては、Google Payでいくか、Paypalでいくか、みたいなものでしょう。（多分）利用可能なCPはあらかじめユーザーが登録しておく必要があるのですが、このデモでは固定で２つのCPを選ぶ形になっています。CPを早い段階で選ぶのは、Step6でCPに対して支払い方法を問い合わせする必要があるためです。[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)でいうところのStep4に該当します。

実装としては、次の支払い方法の確認にスムーズに移れるため、[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)のStep4,5を入れ替えた実装をしています。

![aaa](https://i.imgur.com/UcGRWrS.png)

### 支払い方法の確認(get_payment_method)

CPが決定しているので支払い方法を取得していきます。Human Presentのトランザクション様式なので、実際にユーザーに最終確認するタイミングはシーケンスの後ろですが、このタイミングで内部では取得しておく形となります。これも配送料と同じ理屈で、関連する手数料、割引、またはロイヤルティ情報が選択する支払い方法によって変わってくる可能性があるため、その支払い方法の候補をCart Mandate作成までにMAに提示する必要があるためです。

あくまでも内部的な動作なので画面には出ませんが選択したCPと通信するログが出力されます。

```log
ap2_shopping_agent         | [2025-11-01 00:50:29,045] INFO in services.shopping_agent.langgraph_shopping_flow: [select_cp_node] AP2 Step 4: User selected Credential Provider
ap2_shopping_agent         |   User ID: usr_ee3014bbc51f4156
ap2_shopping_agent         |   CP ID: did:ap2:cp:demo_cp
ap2_shopping_agent         |   CP Name: AP2 Demo Credential Provider
ap2_shopping_agent         | [2025-11-01 00:50:29,255] INFO in services.shopping_agent.langgraph_shopping_flow: [get_payment_methods_node] AP2 Step 6-7: Requesting payment methods from CP
ap2_shopping_agent         |   User ID: usr_ee3014bbc51f4156
ap2_shopping_agent         |   CP ID: did:ap2:cp:demo_cp
ap2_shopping_agent         |   CP URL: http://credential_provider:8003
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.257749Z", "level": "INFO", "logger": "agent", "message": "[ShoppingAgent] Requesting payment methods from Credential Provider (http://credential_provider:8003) for user: usr_ee3014bbc51f4156", "module": "agent", "function": "_get_payment_methods_from_cp", "line": 2316}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.261011Z", "level": "INFO", "logger": "agent", "message": "HTTP Request: GET http://credential_provider:8003/payment-methods", "module": "logger", "function": "log_http_request", "line": 182}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.261495Z", "level": "DEBUG", "logger": "agent", "message": "HTTP_REQUEST_RAW: {\"type\": \"HTTP_REQUEST\", \"method\": \"GET\", \"url\": \"http://credential_provider:8003/payment-methods\", \"headers\": {}, \"body\": null}", "module": "logger", "function": "log_http_request", "line": 193}
ap2_credential_provider    | {"timestamp": "2025-11-01T00:50:29.569821Z", "level": "INFO", "logger": "provider", "message": "[get_payment_methods] Retrieved 1 payment methods for user: usr_ee3014bbc51f4156", "module": "provider", "function": "get_payment_methods", "line": 631}
ap2_credential_provider    | INFO:     172.18.0.9:34006 - "GET /payment-methods?user_id=usr_ee3014bbc51f4156 HTTP/1.1" 200 OK
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.576076Z", "level": "INFO", "logger": "agent", "message": "HTTP Response: 200 (317.37ms)", "module": "logger", "function": "log_http_response", "line": 215}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.576146Z", "level": "DEBUG", "logger": "agent", "message": "HTTP_RESPONSE_RAW: {\"type\": \"HTTP_RESPONSE\", \"status_code\": 200, \"headers\": {\"date\": \"Sat, 01 Nov 2025 00:50:28 GMT\", \"server\": \"uvicorn\", \"content-length\": \"252\", \"content-type\": \"application/json\"}, \"body\": {\"user_id\": \"usr_ee3014bbc51f4156\", \"payment_methods\": [{\"id\": \"pm_e6367cd7\", \"type\": \"basic-card\", \"display_name\": \"Visaカード (****1111)\", \"brand\": \"Visa\", \"last4\": \"1111\", \"requires_step_up\": false, \"billing_address\": {\"country\": \"JP\", \"postal_code\": \"111-1111\"}}]}, \"duration_ms\": 317.3692226409912}", "module": "logger", "function": "log_http_response", "line": 226}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.576201Z", "level": "INFO", "logger": "agent", "message": "[ShoppingAgent] Retrieved 1 payment methods from Credential Provider", "module": "agent", "function": "_get_payment_methods_from_cp", "line": 2334}
ap2_shopping_agent         | [2025-11-01 00:50:29,576] INFO in services.shopping_agent.langgraph_shopping_flow: [get_payment_methods_node] AP2 Step 7: Received 1 payment methods from CP
ap2_shopping_agent         |   Payment Methods: ['pm_e6367cd7']
```

CPとの通信はA2Aがいいのか、普通のREST APIがいいのか悩みましたが、ここでは `GET /payment-methods` というREST APIで実装してます。(CPをエージェンティックなエンティティと捉えればA2Aが適している気がしますが、実装していくにつれ、そうには思えなかったので)

ポイントとして、レスポンスにはカードの情報が入りますが、PCIデータ（カード番号そのものやCVCなど）は入っていないことがわかります。

### Intent Mandate送信（fetch_cart）

いよいよIntent MandateをMAに送信します。

実際にA2Aで送信されるIntent Mandate+αは次のようなものになります。(A2Aメッセージを送信する際のhttpxのリクエスト時のデバッグログから抽出)

```json
{
  "type": "HTTP_REQUEST",
  "method": "POST",
  "url": "http://merchant_agent:8001/a2a/message",
  "headers": {},
  "body": {
    "header": {
      "message_id": "a2d45408-afbc-4891-af66-647e82665f25",
      "sender": "did:ap2:agent:shopping_agent",
      "recipient": "did:ap2:agent:merchant_agent",
      "timestamp": "2025-11-01T00:50:29.785905Z",
      "nonce": "cc624e26345bfe79c092580578dbba04a14f46c27d44077b2d89303a35970833",
      "schema_version": "0.9",
      "proof": {
        "algorithm": "ed25519",
        "signatureValue": "aMCMUarSscFWY8/j+NKdKflvyzdMjpZHJJqGXuKWsW/XqO0loXpUIfrFFTBzenXXPAajkw7IpQYMWtv4ytyNDg==",
        "publicKeyMultibase": "z6MkwMTmaSbsecH3zoTBSAEY2vuMxguAebRnruND2a8oVvcq",
        "kid": "did:ap2:agent:shopping_agent#key-2",
        "created": "2025-11-01T11:42:36.177985Z",
        "proofPurpose": "authentication"
      },
      "signature": null
    },
    "dataPart": {
      "@type": "ap2.mandates.IntentMandate",
      "id": "intent_a97064a3",
      "payload": {
        "intent_mandate": {
          "id": "intent_a97064a3",
          "type": "IntentMandate",
          "user_id": "usr_ee3014bbc51f4156",
          "user_cart_confirmation_required": true,
          "natural_language_description": "かわいいグッズを購入したい。5000円以内",
          "requires_refundability": false,
          "intent_expiry": "2025-11-01T01:50:12.593363Z",
          "created_at": "2025-11-01T00:50:12.593363Z"
        },
        "shipping_address": {
          "recipient": "山田太郎",
          "postal_code": "123-4567",
          "city": "豊島区",
          "region": "東京都",
          "address_line1": "北大塚1-1-1",
          "country": "日本"
        }
      },
      "kind": null,
      "artifact": null
    }
  }
}
```

まずわかりやすくIntent Mandateそものもから見ていきましょう。

```json
{
  "id": "intent_a97064a3",
  "type": "IntentMandate",
  "user_id": "usr_ee3014bbc51f4156",
  "user_cart_confirmation_required": true,
  "natural_language_description": "かわいいグッズを購入したい。5000円以内",
  "requires_refundability": false,
  "intent_expiry": "2025-11-01T01:50:12.593363Z",
  "created_at": "2025-11-01T00:50:12.593363Z"
},
```

~残念ながら、公式ドキュメントそのものにはIntent Mandateの例が載っていないのですが~、公式のGitHubにある[型定義](https://github.com/google-agentic-commerce/AP2/blob/f404a8ddf2e2a5ddf76a6f3fd990b4cb78a71200/src/ap2/types/mandate.py#L32C7-L32C20)を見ると仕様が見えてきます。重要な項目について見ていきましょう。

(公式ドキュメント [A2A Extension for AP2](https://ap2-protocol.org/a2a-extension/#intentmandate-message)に記載がありました。)

#### user_cart_confirmation_required

こちらは、型定義を見ると

> If false, the agent can make purchases on the user's behalf once all purchase conditions have been satisfied. This must be true if theintent mandate is not signed by the user.

とあるので、Intent Mandateにユーザー署名がない、つまりHuman Presentのトランザクション様式では`true`である必要があります。

#### natural_language_description

今回のデモアプリでは、そこまでSAが意図の深堀りをするシナリオになっていないため、「かわいいグッズを購入したい。5000円以内」というユーザーの入力そのものが入っているが、こちらも型定義を見ると

> The natural language description of the user's intent. This is generated by the shopping agent, and confirmed by the user. The goal is to have informed consent by the user.

とあるので、本来はユーザーのテキストそのものが入るのではなく、SAによって解釈された意図が自然言語として入る形です。また、その意図は確認を求める必要がある、というのも明記されています。

#### intent_expiry

Intent Mandateには有効期限があります。これは、時間的な制限を設けることでユーザーの意図が確かに有効であることを保証するためです。

今回は作成後1時間で設定してますが、Human Not Presentの場合はもう少し伸びる気がします。

#### shipping_address

Intent Mandate自体ではないですが、CartをMAが金額もドンピシャで作成するためにshipping_addressも連携しています。AP2の思想を考えると同様に支払い情報も連携する必要がありそうですがこのデモでは省略しています。

#### SAの署名

Intent Mandateそのものとは別に、謎のHeaderというプロパティがありますが、これは、[W3C Verifiable Credentials](https://www.w3.org/TR/vc-data-model-2.0/)のproof構造を踏襲したもので、SAのVerifiable Presentation (VP) に相当するものです。

公式ドキュメントで明確な文献がなかったのですが、[Paypalのブログ](https://developer.paypal.com/community/blog/PayPal-Agent-Payments-Protocol/)によると

> All mandates are expressed as W3C Verifiable Credentials, ensuring tamper resistance, portability, and interoperability across the ecosystem. Mandates embed cryptographically verifiable consent into authorization flows, providing merchants with dispute-grade evidence, issuers with consistent agent-presence signals and consumers with non-repudiable proof of intent.  

とあるため、その仕様に準拠するように作成しました。

具体的には、proof 仕様（RFC 8032 Ed25519）に基づき、メッセージ全体に対して署名付けを行ってます。

署名のアルゴリズムはSAの秘密鍵を使って、ED25519でDatapartをcanonicalized JSON（RFC8785）で署名をつけるようにします。署名の検証のために使う公開鍵はpublicKeyMultibaseで添付されています。先頭文字が`z`であるため、base58btc（主にDIDで使う）を使っていることがわかります。

また、署名の再送や差し替えを防止するためにnonceも生成してます。

このように、署名なども含め様々な処理が入ってやっとIntent MandateをMAに送ることができるのです。

## MAもLangGraph

さて、Intent MandateがMAに送信されましたのでMAが商品カートを作る作業に移ります。

MAもLangGraphで作成されています。こちらはSAからのIntent Mandateを受け取るところからスタートします。

![graph](https://i.imgur.com/Rt5kgtK.png)

### Graphの開始前に署名の検証

LangGraphのグラフには表現されませんが、（デモではA2Aのメッセージハンドラー上で実施しているため）受け取ったA2Aメッセージが本当にSAから実施しているか検証するためにいくつかの検証が入ります。

```log
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.410065Z", "level": "DEBUG", "logger": "v2.common.a2a_handler", "message": "[A2AHandler] Nonce validation successful: nonce=3be7627de7fda009...", "module": "a2a_handler", "function": "verify_message_signature", "line": 156}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.477476Z", "level": "DEBUG", "logger": "v2.common.a2a_handler", "message": "[A2AHandler] Using DID-resolved public key for verification: kid=did:ap2:agent:shopping_agent#key-2", "module": "a2a_handler", "function": "verify_message_signature", "line": 192}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.490047Z", "level": "DEBUG", "logger": "common.crypto", "message": "Verifying A2A message signature", "module": "crypto", "function": "verify_a2a_message_signature", "line": 1037}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.503860Z", "level": "DEBUG", "logger": "common.crypto", "message": "[VERIFY] Canonical JSON length: 797, first 200 chars: {\"dataPart\":{\"@type\":\"ap2.mandates.IntentMandate\",\"id\":\"intent_4956d1e9\",\"payload\":{\"intent_mandate\":{\"created_at\":\"2025-11-01T11:42:11.403084Z\",\"id\":\"intent_4956d1e9\",\"intent_expiry\":\"2025-11-01T12:4", "module": "crypto", "function": "verify_a2a_message_signature", "line": 1041}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.503901Z", "level": "DEBUG", "logger": "common.crypto", "message": "Verifying signature (algorithm: ED25519)", "module": "crypto", "function": "verify_signature", "line": 871}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.513250Z", "level": "INFO", "logger": "common.crypto", "message": "Crypto VERIFY: ED25519 (key: did:ap2:agent:shopping_agent#key-2) - SUCCESS", "module": "logger", "function": "log_crypto_operation", "line": 350}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.513851Z", "level": "INFO", "logger": "v2.common.a2a_handler", "message": "[A2AHandler] proof署名検証成功: sender=did:ap2:agent:shopping_agent, alg=ed25519, kid=did:ap2:agent:shopping_agent#key-2, public_key_source=DID-resolved", "module": "a2a_handler", "function": "verify_message_signature", "line": 223}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.514061Z", "level": "INFO", "logger": "v2.common.a2a_handler", "message": "[A2A処理] ハンドラー実行中: type=ap2.mandates.IntentMandate, from=did:ap2:agent:shopping_agent", "module": "a2a_handler", "function": "handle_message", "line": 305}
```

#### リプレイ攻撃の対策

まず、proof構造が正しいかのチェックをしたあと、Timestamp検証を実施します。これは仕組みは単純で現在時刻から300秒=5分以内に作成されたproofかを確認します。リプレイ攻撃を避けるための基本的な対策にはなります。

また、Nonce検証も実施します。再利用を確認し、単位時間（ここでは300秒=5分)以内に同じNonceを利用していないことを確認します。

#### 公開鍵の取得

さてproof構造からメッセージの署名を検証していきます。まず、署名の検証のためにはSAの公開鍵が必要になります。こちらの公開鍵を取得する方法として、AP2ではDID（Decentralized Identifier／分散型識別子）を使う方法が推奨されていますが、デモアプリではpublicKeyMultibaseを使う方法も合わせてサポートしています。DIDについて馴染みもないと思いますので詳しく見ていきましょう。

##### そもそもDIDとは？

DID（Decentralized Identifier／分散型識別子）は文字通り、分散型（中央集権的な仕組みでない）エンティティを識別する方法です。

署名の検証はproof構造を持ったA2A通信であれば、publicKeyMultibaseに保存されているため、送られたメッセージが途中で改ざんされずに通信を完了したことは判断できます。

しかし欠点として、「鍵」だけでは“誰の鍵か”がわからないという問題があります。おそらく送信先からSAということはわかるのですが、SAがどんなエージェントなのか、詳しいことはわかりません。DIDを使って“信頼の文脈”を作ることができます。

DIDでは`did.json`というJSONファイルを各エンティティの`.well-known/did.json`からアクセスできるようにすることから始めます。例えばSAのdid.jsonは次のとおりです。

```json
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/suites/jws-2020/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ],
  "id": "did:ap2:agent:shopping_agent",
  "verificationMethod": [
    {
      "id": "did:ap2:agent:shopping_agent#key-1",
      "type": "EcdsaSecp256r1VerificationKey2019",
      "controller": "did:ap2:agent:shopping_agent",
      "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEPlqNMbMKh/8HoX2356uZmKM2lVuB\nY71rBhcg1lpuUBncM7LmNAEJO/9WcKboqL+KHKpwGCIEr/oWsizgd89hvA==\n-----END PUBLIC KEY-----\n",
      "publicKeyMultibase": "z2oAtKWnMsubf5MPr6XqWVuLeXVipQ84i4jj2VV9Vu5EZjtQ8"
    },
    {
      "id": "did:ap2:agent:shopping_agent#key-2",
      "type": "Ed25519VerificationKey2020",
      "controller": "did:ap2:agent:shopping_agent",
      "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEAkr3srUb1CmKJq6G0h0PXPnOUtJrTQKL/a8u0J3Ob1wk=\n-----END PUBLIC KEY-----\n",
      "publicKeyMultibase": "z6MkpL5YFLHxAcp6LSJboXQ3nBnNGrQ4TiZRmWBZamPo7t8x"
    }
  ],
  "authentication": [
    "did:ap2:agent:shopping_agent#key-1",
    "did:ap2:agent:shopping_agent#key-2"
  ],
  "assertionMethod": [
    "did:ap2:agent:shopping_agent#key-1",
    "did:ap2:agent:shopping_agent#key-2"
  ],
  "created": "2025-11-02T00:16:30.663059Z",
  "updated": "2025-11-02T00:16:30.663091Z",
  "service": [
    {
      "id": "did:ap2:agent:shopping_agent#a2aendpoint",
      "type": "A2AEndpoint",
      "serviceEndpoint": "http://shopping_agent:8000/a2a",
      "name": "Shopping Agent A2A Endpoint",
      "description": "A2A通信エンドポイント（ユーザー購買代理エージェント）"
    }
  ]
}
```

`did.json`から公開鍵を取得することで、メッセージの署名主が確実にSAであることを示すことができるわけです。ちなみに、AP2におけるDIDのリゾルバーの標準仕様はよくわからず、今回はID `did:ap2:agent:shopping_agent` からDocker Network上のホスト名を取得して、`.well-known/did.json`にアクセスする仕組みを取ってます。

##### publicKeyMultibase

おそらくAP2的にはあまり推奨されないのですが、proof構造に含まれるpublicKeyMultibaseを使った署名の検証もデモアプリではサポートしています。一応、DIDを優先して実施するようにはしてますし、DIDが前提のアーキテクチャの場合、proof構造にpublicKeyMultibaseを入れることは不要なのかもしれません。

#### 検証

いよいよ検証に入ります。ED25519でDatapartをcanonicalized JSON（RFC8785）で署名されたことはわかっていますので、公開鍵を使って検証を実施します。

無事に検証が完了したらSAから確かに送られてきたMandateとわかるので次の処理に移ります。

### Intent MandateからIntentを抽出(analyze_intent)

受け取ったIntent Mandateの`natural_language_description`からキーワードや価格などを抽出してDBに検索できる情報に落とし込む処理をLLMの力を使って実施してます。

次のようなプロンプトが動きます。

```
=========System Prompt==========
あなたはMerchant Agentのインテント分析エキスパートです。
ユーザーのIntentMandate（購入意図）を解析し、以下の情報を抽出してください:

primary_need: ユーザーの主な要求（1文で簡潔に、日本語）
budget_strategy: 予算戦略（"low"=最安値優先、"balanced"=バランス型、"premium"=高品質優先）
key_factors: 重視する要素のリスト（例: ["品質", "価格", "ブランド", "デザイン"]）
search_keywords: 商品検索用のキーワードリスト（日本語、3-5個、商品名に含まれそうな単語）
重要:

search_keywordsは必ず日本語で返してください（例: ["かわいい", "グッズ", "Tシャツ"]）
商品データベースは日本語の商品名（例: "むぎぼーTシャツ", "むぎぼーマグカップ"）なので、日本語キーワードが必須です
必ずJSON形式で返答してください。

=========User Prompt===========
以下のIntentMandateを分析してください:

自然言語説明: かわいいグッズを購入したい。5000円以内
制約条件: {}

JSON形式で返答してください（search_keywordsは必ず日本語）:
{
"primary_need": "...",
"budget_strategy": "low/balanced/premium",
"key_factors": ["...", "..."],
"search_keywords": ["...", "...", "..."]
}
```

今回は育休中でお金がないので、ローカルLLMを使っているためそこまでIntentを正しく抽出できていない気がしますが、きっと最新モデルだともう少しちゃんと出るはずです。

```json
{
    "role": "assistant",
    "content": {
        "primary_need": "かわいいグッズを5000円以内で購入したい",
        "budget_strategy": "low",
        "key_factors": [
            "価格",
            "デザイン"
        ],
        "search_keywords": [
            "かわいい",
            "グッズ",
            "小物"
        ]
    },
    "additional_kwargs": {
        "refusal": null
    }
}
```

### MCPサーバー経由で商品検索DBへ検索(search_products)

AP2はA2A、MCPと対立する技術ではなく、拡張するもの、ということが公式ドキュメントでも強調されています。そこで、今回は商品検索のツール利用はMCPサーバーを利用することにしました。（Streamable HTTP）

商品検索そのものは全文検索エンジンを使いたかったので軽量なmelisearchを使っています。

Initialize処理などを省略しますが、　`tools/call`で次のようなリクエストをMAからMAが使うMCPサーバーへ飛ばしていることがわかります。

```json
{
  "type": "HTTP_REQUEST",
  "method": "POST",
  "url": "http://merchant_agent_mcp:8011/",
  "headers": {
    "Content-Type": "application/json",
    "Mcp-Session-Id": "2ade50e5-f2ae-439c-becb-0ba97bd1a161"
  },
  "body": {
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "search_products",
      "arguments": {
        "keywords": [
          "かわいい",
          "グッズ",
          "安価"
        ],
        "limit": 20
      }
    },
    "id": 387151
  }
}
```

結果は次のように返ってきます。商品のIDはRDB（SQLite）にある商品IDと一致しています。

```json
{
  "type": "HTTP_RESPONSE",
  "status_code": 200,
  "headers": {
    "date": "Sun, 02 Nov 2025 00:21:39 GMT",
    "server": "uvicorn",
    "content-length": "3086",
    "content-type": "application/json"
  },
  "body": {
    "jsonrpc": "2.0",
    "id": 387151,
    "result": {
      "content": [
        {
          "type": "text",
          "text": "{\"products\": [{\"id\": \"286acdd4-d1c1-4860-b06a-f87d2f916a8d\",\"sku\": \"MUGI-KEYCHAIN-001\",\"name\": \"むぎぼーアクリルキーホルダー\",\"description\": \"かわいいむぎぼーのアクリルキーホルダー。バッグやポーチに付けて持ち歩けます。\",\"price_cents\": 80000,\"price_jpy\": 800.0,\"inventory_count\": 100,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"9f58d67c-5c45-4cd4-bf10-73f06647c234\",\"sku\": \"MUGI-CLOCK-001\",\"name\": \"むぎぼー時計\",\"description\": \"むぎぼーデザインのかわいい壁掛け時計。お部屋を明るく彩ります。\",\"price_cents\": 350000,\"price_jpy\": 3500.0,\"inventory_count\": 30,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"2faf8370-ada4-45d4-812c-ef5818d526b5\",\"sku\": \"MUGI-POUCH-001\",\"name\": \"むぎぼーポーチ\",\"description\": \"むぎぼー柄のかわいいポーチ。小物入れやペンケースとして使えます。\",\"price_cents\": 95000,\"price_jpy\": 950.0,\"inventory_count\": 120,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"1d9f08d9-51a9-491e-810b-f0e225ef4f59\",\"sku\": \"MUGI-MUG-001\",\"name\": \"むぎぼーマグカップ\",\"description\": \"むぎぼーがプリントされたかわいいマグカップ。毎日のティータイムが楽しくなります。\",\"price_cents\": 120000,\"price_jpy\": 1200.0,\"inventory_count\": 80,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"c688d6ef-615f-43f7-87ce-05568ae4e63c\",\"sku\": \"MUGI-SOCKS-001\",\"name\": \"むぎぼー靴下\",\"description\": \"むぎぼーがワンポイントで入ったかわいい靴下。やわらかい履き心地。\",\"price_cents\": 85000,\"price_jpy\": 850.0,\"inventory_count\": 100,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"6a169d3a-ca5a-4575-a08b-3fb659c628ed\",\"sku\": \"MUGI-PLATE-001\",\"name\": \"むぎぼープレート皿\",\"description\": \"むぎぼーが中央に描かれた陶器プレート。食卓をかわいく演出。\",\"price_cents\": 190000,\"price_jpy\": 1900.0,\"inventory_count\": 70,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30}]}"
        }
      ],
      "isError": false
    }
  },
  "duration_ms": 1208.6033821105957
}
```

### 在庫チェック(check_inventory)

商品が検索できたらその商品の在庫状況をまたMCPサーバー経由で問い合わせます。こちらはRDB（SQLite）への問い合わせですが、search_productsと同様SteamableHTTPでの通信なので詳細は割愛します。次のような各商品の在庫状況を取得します。

```json
{
  "3446cca8-fe68-4354-a518-63eb3e47d27f": 100,
  "1530a7db-6b7a-458e-b7b9-f510f6fdaa89": 30,
  "cf08568b-8115-461c-aa7e-5a2e07bf4476": 120,
  "e534386f-c89b-4548-9734-78bd34958f88": 80,
  "eb0e5de8-679d-4445-8e64-a1d4d40097fd": 100,
  "f0f41c9f-a31d-4a88-a180-96149a9057fc": 70
}
```

### カート候補作成(optimize_cart)

いよいよカートの作成を実施します。ローカルLLMに3つのカートプランを作成してもらうノードとなります。

次のようなプロンプトが走ります。

```
========System Prompt=========
あなたはMerchant Agentのカート最適化エキスパートです。
ユーザーの購入意図と商品リストから、最適なカートプラン3つを提案してください。

各プランには以下を含めてください:

name: プラン名（予算や特徴を含む、例: "予算内プラン (5,000円)"）
description: プランの説明（1-2文）
items: 商品リスト [{"product_id": 123, "quantity": 1}, ...]
プラン設計のガイドライン:

プラン1: 予算内で最もコスパが良いプラン
プラン2: 予算を少し超えても高品質なプラン
プラン3: シンプルに1-2商品のみのプラン
必ずJSON配列形式で返答してください。

=======User Prompt============
以下の条件でカートプランを3つ提案してください:

ユーザーの要求: かわいいグッズを5000円以内で購入したい
予算戦略: low
重視要素: 価格, デザイン
予算上限: 指定なし

商品リスト（6件）:
[
  {
    "id": "3446cca8-fe68-4354-a518-63eb3e47d27f",
    "name": "むぎぼーアクリルキーホルダー",
    "price_jpy": 800.0,
    "category": null,
    "inventory": 100
  },
  {
    "id": "1530a7db-6b7a-458e-b7b9-f510f6fdaa89",
    "name": "むぎぼー時計",
    "price_jpy": 3500.0,
    "category": null,
    "inventory": 30
  },
  {
    "id": "cf08568b-8115-461c-aa7e-5a2e07bf4476",
    "name": "むぎぼーポーチ",
    "price_jpy": 950.0,
    "category": null,
    "inventory": 120
  },
  {
    "id": "e534386f-c89b-4548-9734-78bd34958f88",
    "name": "むぎぼーマグカップ",
    "price_jpy": 1200.0,
    "category": null,
    "inventory": 80
  },
  {
    "id": "eb0e5de8-679d-4445-8e64-a1d4d40097fd",
    "name": "むぎぼー靴下",
    "price_jpy": 850.0,
    "category": null,
    "inventory": 100
  },
  {
    "id": "f0f41c9f-a31d-4a88-a180-96149a9057fc",
    "name": "むぎぼープレート皿",
    "price_jpy": 1900.0,
    "category": null,
    "inventory": 70
  }
]

JSON配列形式で返答してください:
[
  {
    "name": "プラン名（価格含む）",
    "description": "プラン説明",
    "items": [{"product_id": 123, "quantity": 1}]
  },
  ...
]
```

残念ながらローカルLLMの性能だと、本当に最適なプランを出してきてくれないこともありますし、JSONが不完全なこともあるのですが....。うまくいくと次のようなJSONが出力されます。

```json
[
    {
        "name": "コスパ最強プラン (1,650円)",
        "description": "価格重視で最安値のキーホルダーと靴下を組み合わせたプラン。かわいさと予算を両立させます。",
        "items": [
            {
                "product_id": "286acdd4-d1c1-4860-b06a-f87d2f916a8d",
                "quantity": 1
            },
            {
                "product_id": "c688d6ef-615f-43f7-87ce-05568ae4e63c",
                "quantity": 1
            }
        ]
    },
    {
        "name": "高品質プラン (2,150円)",
        "description": "かわいさを重視してポーチとマグカップを組み合わせたプラン。品質とデザインのバランスが良いです。",
        "items": [
            {
                "product_id": "2faf8370-ada4-45d4-812c-ef5818d526b5",
                "quantity": 1
            },
            {
                "product_id": "1d9f08d9-51a9-491e-810b-f0e225ef4f59",
                "quantity": 1
            }
        ]
    },
    {
        "name": "シンプルプラン (800円)",
        "description": "予算を抑えたい方におすすめのキーホルダー単品プラン。かわいらしさを最大限に活かした1点です。",
        "items": [
            {
                "product_id": "286acdd4-d1c1-4860-b06a-f87d2f916a8d",
                "quantity": 1
            }
        ]
    }
]
```

この時点ではカート候補を作成しているだけなので、正式なCart Mandate形式でもないですし、お店側（Merchant）の署名はついていません。

### Cart Mandate作成・お店の署名をつける(build_cart_mandates)

作成されたカート候補を一つ一つCart Mandateの形式に整形します。この動きもMCPサーバーで実施しています。

また、作成されたCart Mandateにお店側（Merchant）の署名を付けてもらいます。

ログで追うと複雑なので、シーケンスにしてみました。（ログをClaudeに貼り付けるだけでシーケンスできるのは便利ですねぇ...。）

![seq](https://i.imgur.com/ZdvcF4x.png)

作成されたCart Mandateの一つがこんな感じです。

```json
{
  "signed_cart_mandate": {
    "contents": {
      "id": "cart_70dda49a",
      "user_cart_confirmation_required": true,
      "payment_request": {
        "method_data": [],
        "details": {
          "id": "cart_70dda49a",
          "display_items": [
            {
              "label": "むぎぼーアクリルキーホルダー",
              "amount": {
                "value": 800.0,
                "currency": "JPY"
              },
              "refund_period": 2592000
            },
            {
              "label": "消費税（10%）",
              "amount": {
                "value": 80.0,
                "currency": "JPY"
              },
              "refund_period": 0
            },
            {
              "label": "送料",
              "amount": {
                "value": 500.0,
                "currency": "JPY"
              },
              "refund_period": 0
            }
          ],
          "total": {
            "label": "合計",
            "amount": {
              "value": 1380.0,
              "currency": "JPY"
            }
          }
        },
        "shipping_address": null
      },
      "cart_expiry": "2025-11-02T01:23:03.698740Z",
      "merchant_name": "むぎぼーショップ"
    },
    "merchant_authorization": "eyJhbGciOiJFUzI1NiIsImtpZCI6ImRpZDphcDI6bWVyY2hhbnQ6bXVnaWJvX21lcmNoYW50I2tleS0xIiwidHlwIjoiSldUIn0.eyJhdWQiOiJkaWQ6YXAyOmFnZW50OnBheW1lbnRfcHJvY2Vzc29yIiwiY2FydF9oYXNoIjoiY2QxNGY5ODJhYzNhZDNjMzA1NzUxOGM0NWE0ZGVhNzFkMTQ1MjY0YWNkZDQ2ZmFhNGI1OThmNTk4ODlhYzVhNiIsImV4cCI6MTc2MjA0NjU4NCwiaWF0IjoxNzYyMDQyOTg0LCJpc3MiOiJkaWQ6YXAyOm1lcmNoYW50Om11Z2lib19tZXJjaGFudCIsImp0aSI6IjBlMjdjMmRlLTc4ZmYtNDJkMC1iNTc5LWVkYTcwOTFhOWI4ZCIsInN1YiI6ImRpZDphcDI6bWVyY2hhbnQ6bXVnaWJvX21lcmNoYW50In0._UljwTFRm2hJYNNKTJVXHEE9egnkFsoI829Be_RGTb_-OaORUjD2BvmfnVF6V-Y9atDopYtDgp3t1zoMLoQmaQ",
    "_metadata": {
      "intent_mandate_id": null,
      "merchant_id": "did:ap2:merchant:mugibo_merchant",
      "created_at": "2025-11-02T00:23:03.698753Z",
      "cart_name": "シンプルプラン (800円)",
      "cart_description": "予算を抑えたい方におすすめのキーホルダー単品プラン。かわいらしさを最大限に活かした1点です。",
      "raw_items": [
        {
          "product_id": "286acdd4-d1c1-4860-b06a-f87d2f916a8d",
          "name": "むぎぼーアクリルキーホルダー",
          "description": "かわいいむぎぼーのアクリルキーホルダー。バッグやポーチに付けて持ち歩けます。",
          "quantity": 1,
          "unit_price": {
            "value": 800.0,
            "currency": "JPY"
          },
          "total_price": {
            "value": 800.0,
            "currency": "JPY"
          },
          "image_url": null
        }
      ]
    }
  },
  "merchant_authorization": "eyJhbGciOiJFUzI1NiIsImtpZCI6ImRpZDphcDI6bWVyY2hhbnQ6bXVnaWJvX21lcmNoYW50I2tleS0xIiwidHlwIjoiSldUIn0.eyJhdWQiOiJkaWQ6YXAyOmFnZW50OnBheW1lbnRfcHJvY2Vzc29yIiwiY2FydF9oYXNoIjoiY2QxNGY5ODJhYzNhZDNjMzA1NzUxOGM0NWE0ZGVhNzFkMTQ1MjY0YWNkZDQ2ZmFhNGI1OThmNTk4ODlhYzVhNiIsImV4cCI6MTc2MjA0NjU4NCwiaWF0IjoxNzYyMDQyOTg0LCJpc3MiOiJkaWQ6YXAyOm1lcmNoYW50Om11Z2lib19tZXJjaGFudCIsImp0aSI6IjBlMjdjMmRlLTc4ZmYtNDJkMC1iNTc5LWVkYTcwOTFhOWI4ZCIsInN1YiI6ImRpZDphcDI6bWVyY2hhbnQ6bXVnaWJvX21lcmNoYW50In0._UljwTFRm2hJYNNKTJVXHEE9egnkFsoI829Be_RGTb_-OaORUjD2BvmfnVF6V-Y9atDopYtDgp3t1zoMLoQmaQ"
}
```

#### Merchant Authorization

お店側の署名の付け方が全然わからなかったのですが、[公式GitHubの実装例](https://github.com/google-agentic-commerce/AP2/blob/f404a8ddf2e2a5ddf76a6f3fd990b4cb78a71200/src/ap2/types/mandate.py#L114C3-L114C25)を確認するとおおよそ答えがわかりました。

> A base64url-encoded JSON Web Token (JWT) that digitally
> 
> signs the cart contents, guaranteeing its authenticity and integrity:
> 
> 1. Header includes the signing algorithm and key ID.
> 
> 2. Payload includes:
> 
> - iss, sub, aud: Identifiers for the merchant (issuer) and the intended recipient (audience), like a payment processor.
> 
> - iat: iat, exp: Timestamps for the token's creation and its short-lived expiration (e.g., 5-15 minutes) to enhance security.
> 
> - jti: Unique identifier for the JWT to prevent replay attacks.
> 
> - cart_hash: A secure hash of the CartMandate, ensuring integrity. The hash is computed over the canonical JSON representation of the CartContents object.
> 
> 3. Signature: A digital signature created with the merchant's private key. It allows anyone with the public key to verify the token's authenticity and confirm that the payload has not been tampered with.
> 
> The entire JWT is base64url encoded to ensure safe transmission.

つまり、Base64でエンコードされたcart_hashを含めたJWTを作ればよいということだそうです。なので、MAから送信されたされたカートにJWTで署名をつけたものをお店側（Merchant）のエンティティから返しています。なので、merchant_authorizationを<https://www.jwt.io/>で検証すると次のように確かに有効なJWTとなっているはずです。

![aa](https://i.imgur.com/HtFZIgf.png)

このデモアプリでは、お店の署名は自動で行ってますが、 フロントエンドから `/merchant` にアクセスすることで、お店側のカート承認を体験することもできます。

![img](https://i.imgur.com/FrVwUYu.gif)

### カートランキング付け(rank_and_select)

デモアプリでは実装をスキップしてますが、選定されたカートのランキングを入れ替えたりしてUXをよくします。やっぱり最初にいい商品が出てきたほうが購買意欲は高くなりますからね。

例えば、
- ユーザー嗜好マッチ度
- 在庫確実性
- 価格競争力

などでカートの順番を入れ替えます。

### A2Aメッセージ送信

これでCart Mandateが出来上がったのでSAにA2A Messageで送信します。

このデモではカート候補が複数あるため、A2A MessageのArtifactsにそれぞれのCart Mandate格納するようにしています。（これが仕様的に正しいのかわからないものの、一度に複数候補送るにはいいかなと...。）

Intent Mandate同様、user_cart_confirmation_requiredをtrueにして、ユーザーにカートの中身を確定してもらう、つまりHuman Presentのトランザクション様式で動きます。

また、特徴的なのは、Cartの商品については、[W3CのPayment Request](https://www.w3.org/TR/payment-request/#paymentrequest-interface)に準拠する旨が[公式GitHub](https://github.com/google-agentic-commerce/AP2/blob/f404a8ddf2e2a5ddf76a6f3fd990b4cb78a71200/src/ap2/types/payment_request.py#L184)に記載されています。W3CのPayment Request仕様に従ってPaymentMethodDataやPaymentOptionsも含めてます。

ここで問題になるのは、[商品そのもので載せられる情報に限りがある](https://github.com/google-agentic-commerce/AP2/blob/f404a8ddf2e2a5ddf76a6f3fd990b4cb78a71200/src/ap2/types/payment_request.py#L47)という点です。label、amount、pending、refund_periodの4項目しか定義できません。Cart Mandateとしては十分なのかもしれませんが、実際のUI/UXを考えると、例えば商品の説明だったり、商品の画像などをユーザーに見せながら購買させたいものです。よって、Mandateそのものではなく、そのMetadataに記載するようにしています。

また、Intent Mandate同様、Cart Mandateにも有効期限をつけています。これにより時間が立ちすぎて在庫切れになってしまった、ということを予防できるでしょう。

これらのDataPartを持ったA2A MessageにはMAの署名をIntent Mandateのとき同様付けます。

```json
{
  "type": "HTTP_RESPONSE",
  "status_code": 200,
  "headers": {
    "date": "Sun, 02 Nov 2025 11:11:45 GMT",
    "server": "uvicorn",
    "content-length": "10892",
    "content-type": "application/json"
  },
  "body": {
    "header": {
      "message_id": "b9db77f4-a7bb-4ca3-bebb-286a29aea4af",
      "sender": "did:ap2:agent:merchant_agent",
      "recipient": "did:ap2:agent:shopping_agent",
      "timestamp": "2025-11-02T11:14:19.459063Z",
      "nonce": "d1fb8412e81e1b61a600b72214b114e27f2939169bb6a9650e4dd83093a893f8",
      "schema_version": "0.2",
      "proof": {
        "algorithm": "ed25519",
        "signatureValue": "AHTY0v7VQVALn2H8gsnbRyEot0on4QIcRDBIpDeJeBHm13WpnVauVToqyTey+C6p0/syMBq5y0y/UC8Zotj1Ag==",
        "publicKeyMultibase": "z6Mko44YAnz8G71TocDDKoBqg86BJTxnqLN86UvGcpjxP47t",
        "kid": "did:ap2:agent:merchant_agent#key-2",
        "created": "2025-11-02T11:14:19.459063Z",
        "proofPurpose": "authentication"
      }
    },
    "dataPart": {
      "@type": "ap2.responses.CartCandidates",
      "id": "63ff3cf2-b28c-4a0b-9458-9fa7110cf77c",
      "payload": {
        "intent_mandate_id": "intent_21dfc414",
        "cart_candidates": [
          {
            "artifactId": "artifact_b66852e4",
            "name": "コスパ最適プラン (4,500円)",
            "parts": [
              {
                "kind": "data",
                "data": {
                  "ap2.mandates.CartMandate": {
                    "contents": {
                      "id": "cart_2d6be3f2",
                      "user_cart_confirmation_required": true,
                      "payment_request": {
                        "method_data": [
                          {
                            "supported_methods": "basic-card",
                            "data": {
                              "supportedNetworks": [
                                "visa",
                                "mastercard",
                                "jcb",
                                "amex"
                              ],
                              "supportedTypes": [
                                "credit",
                                "debit"
                              ]
                            }
                          },
                          {
                            "supported_methods": "https://a2a-protocol.org/payment-methods/ap2-payment",
                            "data": {
                              "version": "0.2",
                              "processor": "did:ap2:agent:payment_processor",
                              "supportedMethods": [
                                "credential-based",
                                "attestation-based"
                              ]
                            }
                          }
                        ],
                        "details": {
                          "id": "cart_2d6be3f2",
                          "display_items": [
                            {
                              "label": "むぎぼーアクリルキーホルダー",
                              "amount": {
                                "value": 800.0,
                                "currency": "JPY"
                              },
                              "refund_period": 2592000
                            },
                            {
                              "label": "むぎぼーポーチ",
                              "amount": {
                                "value": 950.0,
                                "currency": "JPY"
                              },
                              "refund_period": 2592000
                            },
                            {
                              "label": "むぎぼー靴下",
                              "amount": {
                                "value": 850.0,
                                "currency": "JPY"
                              },
                              "refund_period": 2592000
                            },
                            {
                              "label": "むぎぼーマグカップ",
                              "amount": {
                                "value": 1200.0,
                                "currency": "JPY"
                              },
                              "refund_period": 2592000
                            },
                            {
                              "label": "消費税（10%）",
                              "amount": {
                                "value": 380.0,
                                "currency": "JPY"
                              },
                              "refund_period": 0
                            },
                            {
                              "label": "送料",
                              "amount": {
                                "value": 500.0,
                                "currency": "JPY"
                              },
                              "refund_period": 0
                            }
                          ],
                          "total": {
                            "label": "合計",
                            "amount": {
                              "value": 4680.0,
                              "currency": "JPY"
                            }
                          }
                        },
                        "options": {
                          "request_payer_name": true,
                          "request_payer_email": true,
                          "request_payer_phone": false,
                          "request_shipping": true,
                          "shipping_type": "shipping"
                        },
                        "shipping_address": {
                          "postal_code": "111-2222",
                          "recipient": "山田太郎",
                          "city": "豊島区",
                          "region": "東京",
                          "address_line1": "北大塚1-1-1",
                          "country": "日本"
                        }
                      },
                      "cart_expiry": "2025-11-02T12:14:19.255994Z",
                      "merchant_name": "むぎぼーショップ"
                    },
                    "merchant_authorization": "eyJhbGciOiJFUzI1NiIsImtpZCI6ImRpZDphcDI6bWVyY2hhbnQ6bXVnaWJvX21lcmNoYW50I2tleS0xIiwidHlwIjoiSldUIn0.eyJhdWQiOiJkaWQ6YXAyOmFnZW50OnBheW1lbnRfcHJvY2Vzc29yIiwiY2FydF9oYXNoIjoiYzFhNmE1Y2M3NGUwNDI2YzJiYjI2NzIwM2ZlNTVmNDRjMjg5MjUxNzZmMmUxMzQzODllYzg1YzE2Mzc5OWVmZiIsImV4cCI6MTc2MjA4NTY1OSwiaWF0IjoxNzYyMDgyMDU5LCJpc3MiOiJkaWQ6YXAyOm1lcmNoYW50Om11Z2lib19tZXJjaGFudCIsImp0aSI6Ijc1NWM4MzRjLWU0N2QtNDgwZC1iYzM1LWEwYjI2ZDc4ZGZkYSIsInN1YiI6ImRpZDphcDI6bWVyY2hhbnQ6bXVnaWJvX21lcmNoYW50In0.6GYYQpLcZ1uUUYWpHxQ8qU15koTMuXvaEZGjwMPUSIIPyV03mk1IBDEgYKfY_Z5WZ9HVVVUhmR6GF19qxur9BA",
                    "_metadata": {
                      "intent_mandate_id": "intent_21dfc414",
                      "merchant_id": "did:ap2:merchant:mugibo_merchant",
                      "created_at": "2025-11-02T11:14:19.256092Z",
                      "cart_name": "コスパ最適プラン (4,500円)",
                      "cart_description": "かわいいアイテムを最大限に詰め込んだ予算内プラン。キーホルダー、ポーチ、靴下、マグカップの4点で総額4,500円。",
                      "raw_items": [
                        {
                          "product_id": "286acdd4-d1c1-4860-b06a-f87d2f916a8d",
                          "name": "むぎぼーアクリルキーホルダー",
                          "description": "かわいいむぎぼーのアクリルキーホルダー。バッグやポーチに付けて持ち歩けます。",
                          "quantity": 1,
                          "unit_price": {
                            "value": 800.0,
                            "currency": "JPY"
                          },
                          "total_price": {
                            "value": 800.0,
                            "currency": "JPY"
                          },
                          "image_url": null
                        },
                        {
                          "product_id": "2faf8370-ada4-45d4-812c-ef5818d526b5",
                          "name": "むぎぼーポーチ",
                          "description": "むぎぼー柄のかわいいポーチ。小物入れやペンケースとして使えます。",
                          "quantity": 1,
                          "unit_price": {
                            "value": 950.0,
                            "currency": "JPY"
                          },
                          "total_price": {
                            "value": 950.0,
                            "currency": "JPY"
                          },
                          "image_url": null
                        },
                        {
                          "product_id": "c688d6ef-615f-43f7-87ce-05568ae4e63c",
                          "name": "むぎぼー靴下",
                          "description": "むぎぼーがワンポイントで入ったかわいい靴下。やわらかい履き心地。",
                          "quantity": 1,
                          "unit_price": {
                            "value": 850.0,
                            "currency": "JPY"
                          },
                          "total_price": {
                            "value": 850.0,
                            "currency": "JPY"
                          },
                          "image_url": null
                        },
                        {
                          "product_id": "1d9f08d9-51a9-491e-810b-f0e225ef4f59",
                          "name": "むぎぼーマグカップ",
                          "description": "むぎぼーがプリントされたかわいいマグカップ。毎日のティータイムが楽しくなります。",
                          "quantity": 1,
                          "unit_price": {
                            "value": 1200.0,
                            "currency": "JPY"
                          },
                          "total_price": {
                            "value": 1200.0,
                            "currency": "JPY"
                          },
                          "image_url": null
                        }
                      ]
                    }
                  }
                }
              }
            ]
          },
          {
            "artifactId": "artifact_3ec2cecd",
            "name": "高品質プラン (5,300円)",
            "parts": [...]
          },
          {
            "artifactId": "artifact_4ea2a38f",
            "name": "シンプルプラン (3,500円)",
            "parts": [...]
          }
        ],
        "merchant_id": "did:ap2:merchant:mugibo_merchant",
        "merchant_name": "むぎぼーショップ"
      },
      "kind": null,
      "artifact": null
    }
  }
}
```

## SAに戻って続きの処理を実施

MAからCart Mandateで作られたカート候補を受け取ったら今度は、カートを確定させ支払い処理に進みます。

MAから送信されたA2Aメッセージを前回と同じようにproof構造から署名の検証を実施します。（こちらは本質的に同じ処理なので説明は割愛します。）

またLangGraphのノード続きから処理が再開されます。

### カート選択(select_cart)

カートの選択をユーザーにさせるノードに入りました。

まず、お店側（Merchant）のJWTを検証します。これでお店側も確かに認めたカートと確認できました。

```log
ap2_shopping_agent         | [2025-11-02 22:41:15,996] INFO in services.shopping_agent.langgraph_shopping_flow: [select_cart_node] Merchant authorization JWT verified: merchant=did:ap2:merchant:mugibo_merchant, cart_hash=0049ff8c19257bed...
```

このノードでは、送られてきたCart Mandateの候補からユーザーにカートの選択をさせるノードとなります。

![aa](https://i.imgur.com/Uy0ZnfQ.png)

ユーザーがカートを選択したら、次のノードに進みます。

### ~カート署名(submit_signature)~実際には署名しない

いよいよCart Mandateの選択と確認を実施していきます。

`user_cart_confirmation_required`が`true`なのでユーザーへの確認は必要です。この確認、という作業にTrusted Device Surfaceを利用する点がAP2の面白いところです。

#### Trusted Device Surfaceとは？

Trusted Device Surfaceとは、「信頼できるデバイス面」、もう少し表現をわかりやすくすると「人間が確実に操作しているデバイス面」を意味する言葉です。

このあたりは正直学習不足なので、用語の利用に乱れがありそうで怖いですが、「信頼できる鍵素材（例: TPM / Secure Enclave 内の秘密鍵）」と「人間の操作（タップ・顔認証・指紋）」を結びつけたデバイスを指します。

今回はCPとユーザーの間でPasskeyを登録し、それを利用することで実現しています。（一応生体認証も絡むので、一応それっぽいですが、本当によいのかわからん。ちゃんとこのあたり勉強しないと....）

#### カートには署名をしない

ここは私も実装するまで気が付かなかったのですが、[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)のStep20 - Redirect to trusted device surfaceとあっててっきりCart Mandateにもユーザー署名をつけるものと思ってましたが、これは誤りでした。

まず、[公式GitHubのCart Mandate定義](https://github.com/google-agentic-commerce/AP2/blob/f404a8ddf2e2a5ddf76a6f3fd990b4cb78a71200/src/ap2/types/mandate.py#L107)には、merchant_authorizationはあるものの、user_authorizationは存在しません。

また、せっかくお店側（Merchant）が署名したJWTがJSON構造が変わることで無効なものとなってしまうこともわかりました。考えれば当たり前ですが、シーケンス読むだけではこのあたりに気が付けないのでやはり実装してなんぼなんだと思います。

ただし、Cart Mandateの「"確かな"確認」が必要なので、カート選択時にPasskeyでの認証が要求されます。

#### Passkey(WebAuthn)認証はCPで検証される

ここもかなり複雑なので SAに定義している `/cart/submit-signature` エンドポイントをシーケンスにしてみましょう。

![https://i.imgur.com/NRw8CwW.png]

カート選択後、SAから特殊なSSEイベント(signature_request)を送信します。

![img](https://i.imgur.com/LrfQI8u.png)

Cart Mandateをユーザーに確認させた後、Passkeyで認証ボタンを押すことでフロントエンドからWebAuthnを要求します。すると、パスキーで認証、のポップアップが立ち上がります。（ここでは1Passwordです）

![g](https://i.imgur.com/kJY531p.png)

Passkeyでの認証が完了すると、次のようなWebAuthn attestationが受け取れます。

```json
{
  "id": "dCDQdGlqx50G-UFWp0ORsF5Y7mzWSAkYow",
  "rawId": "dCDQdGlqx50G-UFWp0ORsF5Y7mzWSAkYow",
  "response": {
    "authenticatorData": "xxxxx",
    "clientDataJSON": "xxxxxx",
    "signature": "xxxxxx",
    "userHandle": "usr_cdb4ec851bcf4f73"
  },
  "type": "public-key",
  "attestation_type": "passkey",
  "challenge": "xxxxxx"
}
```

Cart MandateとWebAuthn attestationをCPに送信し、CPにてWebAuthn attestationが確かかを検証してもらいます。

#### CPでの認証

SAからCPにCart MandateとWebAuthn attestationが送信されてきました。PasskeyのIDが設定されているため、自身のDBから該当するPasskeyを探します。もちろんユーザーが一致しているかも確認します。

```log
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.332725Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "[verify_attestation] Found passkey: dCDQdGlqx50G-UFW...", "module": "provider", "function": "verify_attestation", "line": 571}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.332876Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "  User: usr_cdb4ec851bcf4f73", "module": "provider", "function": "verify_attestation", "line": 572}
```

そしてWebAuthn署名検証を実施します。(詳細を説明してしまうと日が暮れそう＆私の無知がバレそうなのでログだけ貼っておきます...。決して疲れてきたわけではない。)

```
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.332725Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "[verify_attestation] Found passkey: dCDQdGlqx50G-UFW...", "module": "provider", "function": "verify_attestation", "line": 571}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.332876Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "  User: usr_cdb4ec851bcf4f73", "module": "provider", "function": "verify_attestation", "line": 572}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.332893Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "  Counter: 0", "module": "provider", "function": "verify_attestation", "line": 573}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.333320Z", "level": "DEBUG", "logger": "common.crypto", "message": "Verifying WebAuthn authentication result", "module": "crypto", "function": "verify_webauthn_signature", "line": 1400}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.333506Z", "level": "DEBUG", "logger": "common.crypto", "message": "Client Data Type: webauthn.get", "module": "crypto", "function": "verify_webauthn_signature", "line": 1421}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.333538Z", "level": "DEBUG", "logger": "common.crypto", "message": "Origin: http://localhost:3000", "module": "crypto", "function": "verify_webauthn_signature", "line": 1422}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.333564Z", "level": "DEBUG", "logger": "common.crypto", "message": "Challenge matched", "module": "crypto", "function": "verify_webauthn_signature", "line": 1434}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.333578Z", "level": "DEBUG", "logger": "common.crypto", "message": "Authentication type: webauthn.get", "module": "crypto", "function": "verify_webauthn_signature", "line": 1441}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.333896Z", "level": "DEBUG", "logger": "common.crypto", "message": "AuthenticatorData parsed: counter=0", "module": "crypto", "function": "verify_webauthn_signature", "line": 1454}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.333911Z", "level": "INFO", "logger": "common.crypto", "message": "Signature counter: 0 (AP2 compliant: replay attacks prevented by user_authorization nonce)", "module": "crypto", "function": "verify_webauthn_signature", "line": 1460}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.338596Z", "level": "DEBUG", "logger": "common.crypto", "message": "RP ID Hash matched", "module": "crypto", "function": "verify_webauthn_signature", "line": 1473}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.357044Z", "level": "INFO", "logger": "common.crypto", "message": "WebAuthn signature verified successfully", "module": "crypto", "function": "verify_webauthn_signature", "line": 1525}
ap2_credential_provider    | {"timestamp": "2025-11-02T23:12:24.366719Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "[verify_attestation] Signature counter: 0 → 0 (AP2準拠: Authenticatorがcounterを実装していない場合でも、user_authorizationのnonceによりリプレイ攻撃は防止されます)", "module": "provider", "function": "verify_attestation", "line": 591}
```

これでTrusted Device Surfaceを使ったユーザーの「"確かな"確認」ができました！

### 支払い方法選択(payment_method_select)

順番が前後しますが、CPから取得していた支払い方法を確定させます。

![aa](https://i.imgur.com/pIWbHta.png)

### 支払い方法のトークン化

支払い方法が確定したので支払い方法に対応する支払いトークン発行をCPに依頼します。

```json
{
  "type": "HTTP_REQUEST",
  "method": "POST",
  "url": "http://credential_provider:8003/payment-methods/tokenize",
  "headers": {},
  "body": {
    "user_id": "usr_cdb4ec851bcf4f73",
    "payment_method_id": "pm_f4745ec2"
  }
}
```

CPから支払い方法に紐づいた支払いトークンが返却されます。以降はこのトークンを使った支払い処理が行われます。

```json
{
  "type": "HTTP_RESPONSE",
  "status_code": 200,
  "headers": {
    "date": "Sun, 02 Nov 2025 23:12:26 GMT",
    "server": "uvicorn",
    "content-length": "176",
    "content-type": "application/json"
  },
  "body": {
    "token": "tok_6c23798f_zfkGVOEF586Lxj9YllxtCFsH",
    "payment_method_id": "pm_f4745ec2",
    "brand": "Visa",
    "last4": "1111",
    "type": "basic-card",
    "expires_at": "2025-11-02T23:27:26.645569Z"
  },
  "duration_ms": 36.832332611083984
}
```

支払いトークンと実際の支払い情報の紐づけはRedis KVで管理しています。デモアプリでは15分のTTLを設けてます。

### Payment Mandate作成・ユーザー署名作成

そろそろフィナーレです！本当にお疲れさまでした..！Payment Mandateを作成します。

最終的に作成されるPayment Mandateは次のようなものです。一つ一つ見ていきましょう。

```json
{
  "type": "HTTP_REQUEST",
  "method": "POST",
  "url": "http://merchant_agent:8001/a2a/message",
  "headers": {},
  "body": {
    "header": {
      "message_id": "3bde0bf1-d43a-48c0-bdaa-2381440cc126",
      "sender": "did:ap2:agent:shopping_agent",
      "recipient": "did:ap2:agent:merchant_agent",
      "timestamp": "2025-11-03T04:33:37.122880Z",
      "nonce": "6cd7d5cb64dc0dd79162d1498167400c673ab95991fda75c60253bed2a76fa26",
      "schema_version": "0.2",
      "proof": {
        "algorithm": "ed25519",
        "signatureValue": "b1AxcN7qA41tPkwbD0DJWxoXXTzb8BBy3rDdynepyw2mefNLI2yqYsYJE+/xmdEXXSIMKL1UIYhAbO5/4MFACw==",
        "publicKeyMultibase": "z6MkpL5YFLHxAcp6LSJboXQ3nBnNGrQ4TiZRmWBZamPo7t8x",
        "kid": "did:ap2:agent:shopping_agent#key-2",
        "created": "2025-11-03T04:33:37.122880Z",
        "proofPurpose": "authentication"
      }
    },
    "dataPart": {
      "@type": "ap2.mandates.PaymentMandate",
      "id": "payment_8229592a",
      "payload": {
        "payment_mandate": {
          "payment_mandate_contents": {
            "payment_mandate_id": "payment_8229592a",
            "payment_details_id": "order_87b47327",
            "payment_details_total": {
              "label": "Total",
              "amount": {
                "value": 2315.0,
                "currency": "JPY"
              }
            },
            "payment_response": {
              "methodName": "https://a2a-protocol.org/payment-methods/ap2-payment",
              "details": {
                "cardBrand": "Visa",
                "token": "tok_b75118d6_puyZ-5Oq9MT8m0Abhx3ux__w",
                "tokenized": true
              }
            },
            "merchant_agent": "did:ap2:merchant:mugibo_merchant",
            "timestamp": "2025-11-03T04:33:33.924986Z"
          },
          "user_authorization": "eyJpc3N1ZXJfand0Ijxxxx.........",
          "id": "payment_8229592a",
          "cart_mandate_id": "cart_fddcfe5d",
          "intent_mandate_id": "intent_88ed322e",
          "payer_id": "usr_cdb4ec851bcf4f73",
          "payee_id": "did:ap2:merchant:mugibo_merchant",
          "amount": {
            "value": 2315.0,
            "currency": "JPY"
          },
          "payment_method": {
            "type": "basic-card",
            "token": "tok_b75118d6_puyZ-5Oq9MT8m0Abhx3ux__w",
            "last4": "1111",
            "brand": "Visa"
          },
          "risk_score": 50,
          "fraud_indicators": [
            "risk_assessment_failed"
          ]
        },
        "cart_mandate": {
          "contents": {
            "id": "cart_fddcfe5d",
            "user_cart_confirmation_required": true,
            "payment_request": {
              "method_data": [
                {
                  "supported_methods": "basic-card",
                  "data": {
                    "supportedNetworks": [
                      "visa",
                      "mastercard",
                      "jcb",
                      "amex"
                    ],
                    "supportedTypes": [
                      "credit",
                      "debit"
                    ]
                  }
                },
                {
                  "supported_methods": "https://a2a-protocol.org/payment-methods/ap2-payment",
                  "data": {
                    "version": "0.2",
                    "processor": "did:ap2:agent:payment_processor",
                    "supportedMethods": [
                      "credential-based",
                      "attestation-based"
                    ]
                  }
                }
              ],
              "details": {
                "id": "cart_fddcfe5d",
                "display_items": [
                  {
                    "label": "むぎぼーアクリルキーホルダー",
                    "amount": {
                      "value": 800.0,
                      "currency": "JPY"
                    },
                    "refund_period": 2592000
                  },
                  {
                    "label": "むぎぼー靴下",
                    "amount": {
                      "value": 850.0,
                      "currency": "JPY"
                    },
                    "refund_period": 2592000
                  },
                  {
                    "label": "消費税（10%）",
                    "amount": {
                      "value": 165.0,
                      "currency": "JPY"
                    },
                    "refund_period": 0
                  },
                  {
                    "label": "送料",
                    "amount": {
                      "value": 500.0,
                      "currency": "JPY"
                    },
                    "refund_period": 0
                  }
                ],
                "total": {
                  "label": "合計",
                  "amount": {
                    "value": 2315.0,
                    "currency": "JPY"
                  }
                }
              },
              "options": {
                "request_payer_name": true,
                "request_payer_email": true,
                "request_payer_phone": false,
                "request_shipping": true,
                "shipping_type": "shipping"
              },
              "shipping_address": {
                "recipient": "あ",
                "postal_code": "あ",
                "city": "あ",
                "region": "あ",
                "address_line1": "あ",
                "country": "あ"
              }
            },
            "cart_expiry": "2025-11-03T05:30:47.679785Z",
            "merchant_name": "むぎぼーショップ"
          },
          "merchant_authorization": "eyJhbGciOixxxxxx......",
          "_metadata": {
            "intent_mandate_id": "intent_88ed322e",
            "merchant_id": "did:ap2:merchant:mugibo_merchant",
            "created_at": "2025-11-03T04:30:47.680226Z",
            "cart_name": "予算内プラン (1,650円)",
            "cart_description": "最安値の商品を組み合わせました",
            "raw_items": [
              {
                "product_id": "286acdd4-d1c1-4860-b06a-f87d2f916a8d",
                "name": "むぎぼーアクリルキーホルダー",
                "description": "かわいいむぎぼーのアクリルキーホルダー。バッグやポーチに付けて持ち歩けます。",
                "quantity": 1,
                "unit_price": {
                  "value": 800.0,
                  "currency": "JPY"
                },
                "total_price": {
                  "value": 800.0,
                  "currency": "JPY"
                },
                "image_url": null
              },
              {
                "product_id": "c688d6ef-615f-43f7-87ce-05568ae4e63c",
                "name": "むぎぼー靴下",
                "description": "むぎぼーがワンポイントで入ったかわいい靴下。やわらかい履き心地。",
                "quantity": 1,
                "unit_price": {
                  "value": 850.0,
                  "currency": "JPY"
                },
                "total_price": {
                  "value": 850.0,
                  "currency": "JPY"
                },
                "image_url": null
              }
            ]
          }
        }
      },
      "kind": null,
      "artifact": null
    }
  }
}
```

#### proof構造

もうおなじみだと思いますが、Payment MandateはSAが作成します。なのでIntent Mandate同様、SAの署名を付けて送ります。このあたりは説明済みなので詳細は省略します。

#### 合計金額（payment_details_total）

Payment Mandateの特徴ですが、あくまでも支払い委任状なので、注目するべきは支払う合計金額です。よって、 `payment_details_total`にはカートの明細は入らず合計金額のみ入ります。

#### payment_response

支払い情報は[支払い方法のトークン化](#支払い方法のトークン化)で取得した一時的な支払いトークンを設定します。

#### user_authorization

Payment Mandateではユーザー署名が必要です。これをどう作るのか、というところの仕様を調べる・実装するのに相当苦労しました。というのも、お店側（Merchant）の場合は、事前に用意した公開鍵・秘密鍵を使ってJWTを作成すればよいですが、ユーザーの公開鍵・秘密鍵とはなんでしょうか？これがよくわからず非常に苦戦していたのですが、実際には、ユーザーの公開鍵・秘密鍵ペアは、WebAuthn（パスキー） を用いてブラウザやOSレベルで安全に管理された鍵を使っていそうなことがわかりました。（おそらく...。間違っていたら指摘してほしいです。）

#### WebAuthn Assertion

WebAuthn（パスキー）の鍵ペアはユーザーのデバイス上で生成され、秘密鍵はデバイスのセキュア領域（例：TPMやSecure Enclave）から外部に出ることはありません。これは、パスキーの登録時に実施される動きです。一方で、公開鍵はCredential Provider（CP）に登録されており、AP2ネットワーク内の他のエージェントがユーザー署名を検証する際に利用されます。

ということは、

- WebAuthnを通じてデバイス内の秘密鍵で署名
- CP経由で公開鍵を取得し、検証する

という流れを踏めばよいわけです。ログから作成したシーケンスがこちらです。これを一つ一つ追っていきましょう。

![aaa](https://i.imgur.com/HPOddbh.png)

#### CPからパスキーの公開鍵をもらう

SAがCPにパスキーの公開鍵を要求すると、COSE(CBOR Object Signing and Encryption)形式の公開鍵を返します。

```
ap2_credential_provider    | {"timestamp": "2025-11-03T07:54:36.506247Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "[get_passkey_public_key] Public key retrieved: credential_id=dCDQdGlqx50G-UFW..., user_id=usr_cdb4ec851bcf4f73", "module": "provider", "function": "get_passkey_public_key", "line": 1536}
ap2_shopping_agent         | {"timestamp": "2025-11-03T07:54:36.507721Z", "level": "DEBUG", "logger": "services.shopping_agent.agent", "message": "HTTP_RESPONSE_RAW: {\"type\": \"HTTP_RESPONSE\", \"status_code\": 200, \"headers\": {\"date\": \"Mon, 03 Nov 2025 07:54:36 GMT\", \"server\": \"uvicorn\", \"content-length\": \"212\", \"content-type\": \"application/json\"}, \"body\": {\"credential_id\": \"dCDQdGlqx50G-UFWp0ORsF5Y7mzWSAkYow\", \"public_key_cose\": \"pQECAyYgASFYIOnePT967mopshGl7tTo53MmMkE/bY6/WZuuZLHSWZYrIlggJj7UcPfh0MaQpNxA5bgmtZPTWi8YVP4x4C8ivq8RFDQ=\", \"user_id\": \"usr_cdb4ec851bcf4f73\"}, \"duration_ms\": 3.767251968383789}", "module": "logger", "function": "log_http_response", "line": 226}
```

COSEについては門戸外の私が説明するとボロが出そうなのですが、「楕円曲線暗号（P-256）」の公開鍵のX, Y座標を含む構造をバイナリにしたもの、という理解で大丈夫だと思います。バイナリにすることで、軽量に扱うことができるわけですね。

#### User Authorization VP作成

User Authorization VP（Verifiable Presentation）とは、「その支払い（Cart + Payment）をユーザーが認可した」その意思を署名して証明することです。

かなり複雑な流れになります&私が門戸外なので拙い説明になりますがお付き合いください。

##### webauthn_challenge取得
まず、受け取ったパスキーでユーザーがユーザー認証を行い、その結果得られる `clientDataJSON` から `challenge（webauthn_challenge）`を取得します。これは、サーバーが認証要求時に生成した一時的なランダム値で、リプレイ攻撃を防ぐために使用します。この値を含めて署名検証を行うことで、ユーザーが実際にサーバーからの要求に応じて署名したことを確認できるというわけです。

```log
ap2_shopping_agent         | [2025-11-03 07:54:36,508] INFO in common.user_authorization: [create_user_authorization_vp] WebAuthn challenge from assertion: eyJtYW5kYXRlX2lk...
```

##### Mandateのハッシュ計算

次に、MandateをRFC 8785 (JSON Canonicalization Scheme)正規化し、SHA-256でハッシュ化します。これでMandateが改ざんされたかどうかを確認することができるわけです。

```log
ap2_shopping_agent         | [2025-11-03 07:54:36,509] INFO in common.user_authorization: [create_user_authorization_vp] cart_hash: 1b6d38d8ef86cf9f...
ap2_shopping_agent         | [2025-11-03 07:54:36,509] INFO in common.user_authorization: [create_user_authorization_vp] payment_hash: 806da3986f122c64...
```

##### COSE形式の公開鍵を復元

先ほどお話した通り、COSE(CBOR Object Signing and Encryption)形式の公開鍵がCPから返却され、これだとJWK(JSON Web Key)として利用しにくいので、復元し後段の処理で利用可能な形にします。

（中身の処理は複雑すぎるので割愛）

```log
ap2_shopping_agent         | [2025-11-03 07:54:36,511] INFO in common.user_authorization: [create_user_authorization_vp] Restored public key from COSE format (DB)
```

##### Issuer JWT を生成しcnf claimを含める

ユーザーをIssuer（発行者）として署名された（ということにした）JWTを生成し、cnf claim(Confirmation claim)にユーザーの公開鍵をJWK形式で埋め込みます。これにより、このあと実施するKey-binding JWTと組み合わせることでMPPなどが検証をするときに「確かにこのユーザーが署名したJWT」という鍵の関連性（Key Binding）が明示できるわけです。

```log
ap2_shopping_agent         | [2025-11-03 07:54:36,511] INFO in common.user_authorization: [create_user_authorization_vp] cnf claim with JWK added to Issuer JWT
```

cfn claimをつけたJWTのペイロードは次のような形になります。(issやsubはユーザーのDIDです。DIDはこのデモアプリのユーザーIDから生成していますが、おそらくはもう少しユニークになるような工夫が必要だと思います。)

```json
{
  "iss": "did:ap2:user:usr_cdb4ec851bcf4f73",
  "sub": "did:ap2:user:usr_cdb4ec851bcf4f73",
  "iat": 1762210741,
  "exp": 1762211041,
  "nbf": 1762210741,
  "cnf": {
    "jwk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "xxxxxxxxxxxxxxx",
      "y": "xxxxxxxxxxxxxxx"
    }
  }
}
```

また、かなり細かい内容にはなるのですが、

> ユーザーをIssuer（発行者）として署名された（ということにした）

という文には含みがあって、実際にはIssuerの公開鍵で署名してません！嘘じゃん！と思うかもですがこれには理由があって、WebAuthn APIは特定のチャレンジに対してのみ署名を生成するため、Issuer JWTに署名する、ということは不可能になります。

やるとすると、WebAuthn以外の方法で生成された鍵を使った署名を実施することになりますが、それだとパスキーで完結するUI/UXになりません。なので、ここは妥協でIssuer JWTには署名を付けず、次で説明するKey-binding JWTにsd_hash（Issuer JWTのハッシュ）を入れることで解決します。

よって、Issuer JWTのヘッダーは、

```python
issuer_jwt_header = {
  "alg": "none",  # JWT標準準拠（RFC 7519）: 署名なしを明示
  "typ": "JWT"
}
```

のように署名がないことを明示しています。

##### Key-binding JWT を生成

次に、MandateハッシュやWebAuthnチャレンジなどのトランザクションデータを含めたJWTを生成します。これにより、Cart MandateやPeyment Mandateの受け渡しつまりトランザクションについて、確実にユーザーが証明しました。ということになるのです。

`transaction_data`にCart MandateやPeyment Mandateのハッシュを入れることで、これらのトランザクション全てにユーザーは承認した、という意思表示ができます。

`webauthn`にassertion の必要データを入れることで、このKey-binding JWTを見るだけで検証が可能となります。（仕様的にこれでいいのか、CPに問い合わせるべきなのかは不明でした。詳しい人...助けて。）

```json
{
  "aud": "did:ap2:agent:payment_processor",
  "nonce": "rH4AgxNBXcnxNlcPXjoP2nLGynP8dmJhdSF96Cngz9w",
  "iat": 1762210741,
  "sd_hash": "xxxx",
  "transaction_data": [
    "xxxxx",
    "xxxxx"
  ],
  "webauthn": {
    "credential_id": "dCDQdGlqx50G-UFWp0ORsF5Y7mzWSAkYow",
    "authenticator_data": "xxxxxxx",
    "client_data_json": "xxxxxxx",
    "user_handle": "usr_cdb4ec851bcf4f73"
  
}
```

##### WebAuthn署名をKB-JWTの署名として扱う（署名化）

さて、Issue JWTとKey-binding JWTができたので、Key-bindng JWTに署名します。ここでポイントなのは、WebAuthn署名を実施するということです。Key-bindng JWTをBase64url形式にしたものをパスキーの認証器に渡し、Signatureを受け取ります。これをKey-binding JWTの署名として扱うわけです。

```log
ap2_shopping_agent         | [2025-11-03 22:32:19,412] INFO in common.user_authorization: [create_user_authorization_vp] Generated SD-JWT+KB user_authorization (IETF standard): length=1571, cart_hash=396e1f1ea5518055..., payment_hash=a07655c1e051df12...
```

##### SD-JWT+KB（issuer_jwt~kb_jwt）組み立て

2つのJWTができましたので、こちらをSD-JWT(Selective Disclosure JWT)とKBの形式で組み立てます。

SD-JWTはJWTの一部のみを選択的に公開する技術ですが、ここではDisclosureとしてKBをつけて署名します。(このフォーマットでいいのかどうなのかはAP2のドキュメントをみてもわからないのですが、多分...大丈夫...。わからん....。)

Base64をデコードしたUser Authorizaion VPは次のようになります。

SD-JWTのHeader
```json
{
  "alg": "none",
  "typ": "JWT"
}
```

SD-JWTのBody
```json
{
  "iss": "did:ap2:user:usr_cdb4ec851bcf4f73",
  "sub": "did:ap2:user:usr_cdb4ec851bcf4f73",
  "iat": 1762214326,
  "exp": 1762214626,
  "nbf": 1762214326,
  "cnf": {
    "jwk": {
      "kty": "EC",
      "crv": "P-256",
      "x": "xxxxx",
      "y": "xxxxx"
    }
  }
}
```

KBのHeader
```json
{
  "alg": "ES256",
  "typ": "kb+jwt"
}
```

KBのBody
```json
{
  "aud": "did:ap2:agent:payment_processor",
  "nonce": "rmPX74BFR6rTBG4Pdu2ec4r9g9BjjkEv_w2l3FAKqh4",
  "iat": 1762214326,
  "sd_hash": "26e0a50c27ea3ffe1af0d221c969503c212f75c1530ba81c4a6dd8fad76ed0ad",
  "transaction_data": [
    "92b50fc46c06554f2eb3786f71917076a8b3a4abf8fdb1c455c0c33f08731408",
    "c66727e7d7bbe76654a860e1dcffb09f0c1d32d2065b2efcb54142dc9d92c3ce"
  ],
  "webauthn": {
    "credential_id": "dCDQdGlqx50G-UFWp0ORsF5Y7mzWSAkYow",
    "authenticator_data": "xxxxxx",
    "client_data_json": "xxxxx",
    "user_handle": "usr_cdb4ec851bcf4f73"
  }
}
```

以上で無事、User Authorization VPを作成できました。お疲れ様でした！

### リスク審査

デモアプリでは簡易的な実装にとどめてますが、SAがPayment Mandateを作成するときに決済に関係するエンティティに正しく事情を伝える必要があるのでリスク審査を実施します。

例えばユーザーのIntentで指定された金額の範囲に取引が収まっているか、指定のブランドで購入が進められているか指定のカードブランドに問題はないか、などです。このあたりは明確な仕様がわからないところなので実際にAP2が本格的に動き出したら調査したいところです。

### Payment Mandate送信

それでは、MAにPayment Mandateを送信します。ペイロードは先ほど貼り付けたものです。

proof構造などを作成し、確かにSAから送信されていることと、User Authorization VPをつけて確かにユーザーが承認したことを保証します。

## ついに決済処理！

いよいよ決済処理です。とても長かった...。ここまで読んでいる人いますか...?

### 決済処理はMPPが実施

決済に関する処理はMPPが実施します。これはAP2が役割ベースのアーキテクチャを採用しているためで、決済関係はMPPが一任することになります。

ただし、SAからMPPは見えないので、SAは一旦MAにPeyment Mandateを送信し、MAはMPPにそのままPayment Mandateをパススルーします。(SAからの署名を検証するのはMAです。その後、MAは再度A2Aメッセージに自身の署名を付けてMPPに送信をします。)

### Proof・User Authorization VPの検証

MPPではまず、送信されたPeyment Mandateの検証を行います。今回は2段階で、

- MAから送信されたことを証明するproof構造の検証
- User Authorization VPの検証

の検証を進めます。MAから送信されたことを証明するproof構造の検証は別箇所でも実施している処理なので説明を省略します。

User Authorization VPの検証は、SD-JWT+KBをパースした後、Cart MandateとPeyment Mandateのハッシュが正しいか、WebAuthnで署名されたKBが確からしいかなどを検証します。

```log
ap2_payment_processor      | [2025-11-03 22:32:19,725] INFO in services.payment_processor.utils.mandate_helpers: [PaymentProcessor] PaymentMandate validation passed: payment_556c011e, user_authorization present: eyJhbGciOiJFUzI1NiIs...
ap2_payment_processor      | {"timestamp": "2025-11-03T22:32:19.726152Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "[PaymentProcessor] Mandate chain validation: PaymentMandate(payment_556c011e) → CartMandate(cart_6f9f1032)", "module": "processor", "function": "_validate_mandate_chain", "line": 671}
ap2_payment_processor      | {"timestamp": "2025-11-03T22:32:19.728043Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "[PaymentProcessor] Verifying SD-JWT-VC user_authorization: cart_hash=396e1f1ea5518055..., payment_hash=a07655c1e051df12...", "module": "processor", "function": "_validate_mandate_chain", "line": 688}
ap2_payment_processor      | [2025-11-03 22:32:19,728] INFO in common.user_authorization: [verify_user_authorization_vp] Parsed SD-JWT+KB format successfully
ap2_payment_processor      | [2025-11-03 22:32:19,728] INFO in common.user_authorization: [verify_user_authorization_vp] Hash verification passed: cart_hash=396e1f1ea5518055..., payment_hash=a07655c1e051df12...
ap2_payment_processor      | [2025-11-03 22:32:19,734] INFO in common.user_authorization: [verify_user_authorization_vp] ✓ WebAuthn signature verified successfully
ap2_payment_processor      | [2025-11-03 22:32:19,734] INFO in common.user_authorization: [verify_user_authorization_vp] Key-binding JWT payload verified
ap2_payment_processor      | [2025-11-03 22:32:19,734] INFO in common.user_authorization: [verify_user_authorization_vp] ✓ SD-JWT+KB verification passed (IETF standard)
```

### MPPによる決済処理

さて、いよいよPeyment Mandateを使った決済処理を実施していきます。

#### MPPによるMerchant署名の検証

`merchant_authorization`のJWTがCart Mandateにつけた署名をMPPでも確認し、この取引がお店側の確かな承認があることを検証していきます。merchant_authorizationのJWTの検証と、Cart Mandateのハッシュを照合してCart Mandateがたしかにお店側が署名したものと確認できました。

```log
ap2_payment_processor      | {"timestamp": "2025-11-03T23:58:46.672231Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "[_verify_merchant_authorization_jwt] JWT validation passed: iss=did:ap2:merchant:mugibo_merchant, exp=1762217912, jti=b13c2752-9b28-44..., cart_hash=92b50fc46c06554f...", "module": "processor", "function": "_verify_merchant_authorization_jwt", "line": 613}
ap2_payment_processor      | {"timestamp": "2025-11-03T23:58:46.672387Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "[PaymentProcessor] merchant_authorization JWT verified: iss=did:ap2:merchant:mugibo_merchant", "module": "processor", "function": "_validate_mandate_chain", "line": 725}
ap2_payment_processor      | {"timestamp": "2025-11-03T23:58:46.672493Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "[PaymentProcessor] CartMandate hash in merchant_authorization: 92b50fc46c06554f...", "module": "processor", "function": "_validate_mandate_chain", "line": 733}
ap2_payment_processor      | {"timestamp": "2025-11-03T23:58:46.673139Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "[PaymentProcessor] ✓ CartMandate hash verified (merchant_authorization): 92b50fc46c06554f...", "module": "processor", "function": "_validate_mandate_chain", "line": 750}
```

#### Cart Mandate→Payment Mandateのチェーンが正しいか確認

次に、Payment MandateがCart Mandateを正しく参照しているか、そのチェーンが有効かを確認します。

Cart MandateのIDがPayment Mandateに記載されているため、そのIDが一致しているかをチェックします。

#### 支払いトークンの有効性確認

支払い方法は前回のステップですでにCPによってトークン化されています。そのトークンの有効性と所有権をCPに問い合わせて確認する必要があります。

CPでは、トークンから実際の支払い情報にアクセスし、`payer_id`が一致していることを確認します。

```log
ap2_payment_processor      | {"timestamp": "2025-11-03T23:58:46.679844Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "[PaymentProcessor] Verifying credential with Credential Provider: token=tok_835e197e_AZJUO7_...", "module": "processor", "function": "_verify_credential_with_cp", "line": 916}
ap2_payment_processor      | {"timestamp": "2025-11-03T23:58:46.682497Z", "level": "INFO", "logger": "services.payment_processor.processor", "message": "HTTP Request: POST http://credential_provider:8003/credentials/verify", "module": "logger", "function": "log_http_request", "line": 182}
ap2_payment_processor      | {"timestamp": "2025-11-03T23:58:46.682622Z", "level": "DEBUG", "logger": "services.payment_processor.processor", "message": "HTTP_REQUEST_RAW: {\"type\": \"HTTP_REQUEST\", \"method\": \"POST\", \"url\": \"http://credential_provider:8003/credentials/verify\", \"headers\": {}, \"body\": {\"token\": \"tok_835e197e_AZJUO7_Qat-15UWBHUHtlVG8\", \"payer_id\": \"usr_cdb4ec851bcf4f73\", \"amount\": {\"value\": 6215.0, \"currency\": \"JPY\"}}}", "module": "logger", "function": "log_http_request", "line": 193}
ap2_credential_provider    | {"timestamp": "2025-11-03T23:58:46.721823Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "[verify_credentials] Verifying token for payer: usr_cdb4ec851bcf4f73", "module": "provider", "function": "verify_credentials", "line": 1611}
ap2_credential_provider    | {"timestamp": "2025-11-03T23:58:46.727054Z", "level": "INFO", "logger": "services.credential_provider.provider", "message": "[verify_credentials] Token verified: payment_method_id=pm_f4745ec2, user_id=usr_cdb4ec851bcf4f73", "module": "provider", "function": "verify_credentials", "line": 1648}
ap2_credential_provider    | INFO:     172.18.0.5:40314 - "POST /credentials/verify HTTP/1.1" 200 OK
```

#### リスク審査

SAが実施したリスク審査のスコアを確認し、最終的に決済を行うか、追加で審査するかを確認します。このあたりの具体的なチェック項目はドキュメントを読んでもわからなかったのですが、AIエージェントが決済に関わっていることや、トランザクションの様式によってチェック項目が変わると想定しています。

#### 決済処理

このデモでは決済ネットワークはただのスタブなので詳細は割愛しますが、決済ネットワークに対して決済処理を実施します。

#### レシートの生成とCP・MAへの通知

無事決済が完了したらレシートの発行をします。また、CPに決済の完了とトランザクションの状態、レシート情報を通知します。

また、ユーザーにも完了を通知したいためMA→SA→ユーザーへ通知をします。

#### すべての処理が完了！！！

レシートをユーザーに提示してすべての処理が完了です。

![aa](https://i.imgur.com/zyvCWnm.png)

レシートはこんな感じのPDFにしてます。

![aa](https://i.imgur.com/rzgG5RA.png)
