---
slug: 2025-10-29/AP2に入門する
title: "AP2に入門する"
date: 2025-10-29T04:00:20+0000
description: AP2(Agent Payments Protocol)に入門してみます。
tags:
  - fixme
headerImage: https://i.imgur.com/QmIHfeR.jpg
templateKey: blog-post
---

お久しぶりです。

## Table of Contents

```toc

```

## すごいせっかちな人向けに

デモアプリを作ってみました。

![demo](https://i.imgur.com/4umwhpw.gif)

Docker ComposeでAP2を語るうえで必要なサービスが立ち上がります。

## AP2に入門してみたくなった。

突然ですが、育休を取っているのですが、なにか新しい技術を学んでおかないと復帰後不安で押しつぶされそうなので、重い腰をあげてAP2([Agent Payments Protocol](https://ap2-protocol.org/))に入門しようと思います。

どうにも生成AIの世界は謎のプロトコルが次々とでてくる...。この前MCPに入門したと思ったら、A2A、そしてAP2...。困りましたね。

AP2とは、Googleによると

> 主要な決済企業やテクノロジー企業と共同で開発されたオープン プロトコルで、プラットフォームをまたいでエージェント主導の決済を安全に開始、実行するもの

とのことで、要はAIエージェントを絡めたお買い物、決済を考えたときに起こり得る様々な不都合や問題をうまい具合に解決する仕組みです。

そもそもAIエージェントを用いたお買い物で起こり得る問題ってなんでしょうか。

## まず人間の買い物を想像してみましょう

AP2を考える前に、まずは人間の買い物を想像してみましょう。

![a](https://i.imgur.com/hvUOvHi.png)

Aさんは「かわいい犬のグッズ」がほしいな〜と思っているとします。ちなみに「『かわいい犬のグッズ』がほしいな〜」という気持ち(意図)のことをAP2では、Intentといいます。

しばらく歩いていると、「むぎぼーショップ」というかわいい柴犬をモチーフにしたお店を発見しました。入ってみましょう。

「むぎぼーショップ」は店員さんがとても優秀で、お客様の気持ちによりそった最適な商品を提示してくれるお店でした。細かい要望を伝えると、在庫を確認した後予算内でいくつか商品をピックアップしてくれました。（おすすめセットのリストを作ってくれました）

![a](https://i.imgur.com/E2feFkd.png)

Aさんもおすすめセットに納得したようで支払い手続きに進みます。お店に設置されているxxPayの端末を使ってお会計を済ませます。商品と領収書をもらってお買い物完了です。

![a](https://i.imgur.com/dXUyJlg.png)

以上が人間のお買い物でした。ポイントとしてAP2で想定されるお買い物は、スーパーなどの[セルフサービス方式](https://md-next.jp/yougo/%e3%82%bb%e3%83%ab%e3%83%95%e3%82%b5%e3%83%bc%e3%83%93%e3%82%b9)ではなく、[対面販売](https://md-next.jp/yougo/%E5%AF%BE%E9%9D%A2%E8%B2%A9%E5%A3%B2)を想定しています。

なので、買い物カゴに商品を入れてくれるのは店員さんで、その買い物カゴを確認してOKを出す感じです。

![](https://i.imgur.com/f2gUFXs.png)

この流れをAIエージェントに登場させることを考えていきましょう。

## その買い物、誰が間違えた...?

では、この流れでお買い物の一部をAIエージェントに任せることを想定してみます。

例えば、ユーザーの代わりにお買い物をするお買い物エージェント(Shopping Agent、以降SA)とお店の店員さんの代わりに業務をするお店エージェント(Merchant Agent、以降MA)が追加された図を考えていきます。

### ハルシネーション

まず思い浮かぶのは、AIエージェントのハルシネーション問題です。あたかも知ったように誤った情報をべらべら話すあの現象です。

お買い物というシチュエーションでこれが起きると大変です。しかも、考えられるミスのパターンが多いのも特徴です。

一番想像しやすいのは、ユーザーの意図（Intent)をSAが間違って理解してMAに伝えてしまうパターンです。伝言ゲーム的に間違った意図のもと購入が進められてしまいます。安い買い物ならまだしも、数百万の決済を勝手にやられては困ります。

![ia](https://i.imgur.com/P3B8dhg.png)

他にもMAが意図を間違えて解釈するケースもありそうです。

![aa](https://i.imgur.com/5XVBhIa.png)

さらに複雑なケースを想定すると、ユーザーの意図は正しく伝えられても、お店側の都合、例えばお得意さんしか売ってはいけない商品を売ってしまう、というMA側のコンテキスト不足によるミスもありそうです。

![aaa](https://i.imgur.com/E5N4Gjl.png)

### もっと悩ましいパターン

もっと悩ましいパターンも考えられます。例えばAさんが、AIエージェントには「かわいい犬のグッズがほしい」とお願いしておきながら、その意思を途中で変えてしまう、というものです。

心変わりしたり、いたずらだったり、勘違いだったり色々理由はあると思いますが、ユーザーから「実はかわいい猫のグッズがほしかった」と言われたら誰が責任を取るべきかわからなくなってしまうのも問題です。

![aaa](https://i.imgur.com/aL1N9Yl.png)

また、ユーザーになりすましてAIエージェントに購入の指示をされたりした場合にも同様の問題が起きてしまう可能性もあります。（なりすまし問題）

## AIエージェントが情報を知りすぎる問題

また、少し話の毛色は変わりますが、AIエージェント（SA）がユーザーの代わりにお買い物をする場合、ユーザーのお財布を勝手に使えてしまったりすることも問題です。

クレジットカード決済する場合を想定すると、カードの番号の他、有効期限や、CVC(Card Validation Code、カード裏面にある3桁くらいのコード)を知ってしまうことになります。これでは、万が一のときにカード情報が漏洩したり、AIエージェントが暴走して闇雲に高級品を買いまくったりする危険もありそうです。

加えて、AIエージェント（MA）がお店の決済システムに密結合になってしまうこともシステム保守観点で危うさがあります。

![aa](https://i.imgur.com/W4SrXsP.png)

## AP2ではどんな仕組みでこれらを解決しているのか

AP2ではこれらの課題を高度な暗号技術を組み合わせたデジタル署名をA2A(Agent2Agent)の通信にうまく拡張することで解決します。

### シーケンス

まずは、難しい用語抜きでわかりやすい（？）紙芝居をお見せし、それらで出てくる具体的な概念から用語を抑えたほうがきっとわかりやすいと確信したので、しばし紙芝居にお付き合いください。

（説明の都合で各ステップの順番を入れ替えている箇所があります。また、現時点シーケンスが公開されている[Illustrative Transaction Flow](https://ap2-protocol.org/specification/#71-illustrative-transaction-flow)を参考に作成しています）

![a](https://i.imgur.com/lKKSQnI.png)

まず、Aさんは「かわいい犬のグッズがほしい」「5000円以内」など具体的な購入意図をお買い物エージェント（Shopping Agent、SA）に指示します。すると、SAはその購入意図を汲み取ってお買い物を始めます。

実際にお買い物に移る前に、ユーザーと購入意図を委任状にしたIntent　Mandate、つまり「これから私AはSAに『かわいい犬のグッズを5000円以内』で購入することを委任します。」と委任状を取り交わします。Intent Mandateについては後ほど詳しくお話します。

と同時に、「むぎぼーショップ」のお店エージェント（Merchant Agent、MA）がSAに対して自分のお店の紹介も兼ねて名刺交換します。

A2Aに詳しい方ならピンとくると思いますが、A2AにおけるAgent Cardで自身の取り扱い状況やAP2に対応した購入体験ができますよ、ということを伝えてます。

![c](https://i.imgur.com/0KxrKpp.png)

次に、SAはMAと名刺交換した結果をもとにむぎぼーショップと取引をスタートすることを決めました。A2AのMessageを用いて、SA-MAのエージェント間通信を実施します。

ここでユーザーと取り交わしたIntent Mandateを送ることで、SAがユーザーの意図を確かに汲んだ購入をしていることをMAに示しつつ、目的の商品カートを作ってもらうことをお願いするわけです。

MAはユーザーのIntentを受けて、どんな商品セットがよいか検討を始めます。お店側（Merchant）の在庫状況や各商品の金額、説明などを見極め、ユーザーにぴったりな商品が入った商品カートを作成しにいきます。

![d](https://i.imgur.com/QVFkhfa.png)

さて、MAはついにユーザーにぴったりな商品の入った商品カートを作成しました。この商品カートの作成は本来はお店側(Merchant)が作るべきものですが、MAがお店の代わりに作成しているものですので、委任状の形でお店側の販売行為を委任していることを示す必要があります。

そこで、MAは商品カートの委任状（Cart Mandate）を作成し、お店側に確認と確かに確認したという署名をお店がつけます。

![b](https://i.imgur.com/wPZgNbR.png)

お店とMAの間での委任状の取り交わしが無事完了したら、その委任状（Cart Mandate）をSAに送信します。この商品カートをSAがユーザーに提示しながら実際の購入まで進めていくわけです。

![h](https://i.imgur.com/qNfLrKJ.png)

AさんはSAから提示された商品カートの委任状（Cart Mandate）に基づき、自身が購入する商品カートを確定させます。（Cart MandateはA2A Artifactsの形で複数提示もできるため、複数の候補から選択するUIも想定されうる）

確定した商品カートの委任状について、「確かにAが確定しましたよ」という意味合いで、ユーザーが署名をつけます。（実際にはDevice Attestationの動作が入りますが、Payment Mandateのところで説明します）

![i](https://i.imgur.com/rXcmmUi.png)

同時に、SAはユーザーが商品を購入するにあたっての支払い方法についても確認する必要があります。AP2では、Credential Provider(CP)という謎の概念が出てきます。

公式ドキュメントによると

> 3 The User’s Credentials Provider (CP): A specialized entity responsible for the secure management and execution of payments credentials (e.g. a digital Wallet). It holds knowledge of the User's available payment methods, gets user consent (if deemed necessary) to share credentials with the SA, selects the optimal payment method based on user preferences and transaction context, and handles payment scenarios like errors, declines and transaction challenges gracefully.

とあり、CPはユーザーの支払いおよびID資格情報を安全に管理・実行する専門的なエンティティの意味ですが、ようはデジタルウォレットと思っていただいて良さそうです。イメージとしてはGoogle PayやApple Payのようなスマートフォンからクレジットカードが使えるサービスが近いです。

のちのちユーザーに支払い方法を確認するため、CPに紐づく支払い方法を確認します。現状の仕様ではクレジットカードやデビットカードが選択可能だそうですが、将来的にはSuicaのようなサービスにも対応可能とのことです。

ここでポイントなのは、SAは支払い情報をユーザーに選択させるための最低限の情報（たとえばクレジットカードの下4桁とか）のみ受け取ります。

![f](https://i.imgur.com/Gyc2QU9.png)

では支払いに移りましょう。SAは先程CPから受け取った支払い情報からユーザーが利用する支払い方法を確定させます。ユーザーが支払いに利用するカードを確定させたら、CPにそのカードのトークン(支払い方法トークン、payment method token)を発行依頼します。

このトークンは、一時的な支払い利用の可能なカード情報となります。ただし、トークンには一切支払いに必要な情報(PCIデータ、カード番号とか)は含まれません。CPにはトークンと実情報のマッピングが存在するため、CPを経由することで支払いが可能となるわけです。またトークンはしばしば期限付きの支払能力のある代替通貨となる場合が多いので発行は実際のクレジットカードの決済ネットワークと連携して行われる形です。

支払い方法トークンが取得できたらSAは支払い委任状（Payment Mandate）を作成します。これは商品の細かな明細を含まない合計金額や支払い方法を明記した簡素な委任状となります。まず、ユーザーに「私SAはAさんに変わってこの委任状の通り支払いしますよ」という委任状をSAは提示し、ユーザーから署名をもらうことでユーザー意思を確定させます。

このとき、device attestationの動きが入ります。これはトランザクションの信頼性と否認不可能性を高めるためとされ、TPM、Secure Enclaveなどを用いて、ハードウェアに裏打ちされたキーとインセッション認証（生体認証など）を通じて実行されます。こうすることで確実にAさんが承認しましたよ。という血判状になるんですね。

![e](https://i.imgur.com/ATRxVXv.png)

ユーザー署名付き支払い委任状（Payment Mandate）が出来上がったら、MAに送信し、いよいよ支払いに移ります。

ここで重要なのは、支払い処理そのものはMAは実施せず、お店に紐づく支払いエンティティ（Merchant Payment Processor、MPP）が実施します。これは明確な職務分離というAP2の基本概念に従った実装となります。

![g](https://i.imgur.com/2sJ5eqV.png)

支払いが完了したら領収書をMPPが発行し、CPとSAに送信します。SAは領収書を受け取ってユーザーに取引の完了を伝えます。これがAP2で実現される動きです。

お疲れ様でした！

### 委任状（Mandate）

あらためて、AP2を語るうえで欠かせないのが委任状(Mandate)と呼ばれるデジタル署名付きの正式な委任証明の仕組みを再確認しましょう。

詳細はこのあとのコードでの説明で語ることとして、ユーザー・AIエージェント・お店などがそれぞれ持っている秘密鍵を使って委任状のJSONにデジタル署名を行い、その検証を各工程で実施することで、その委任が各エンティティが確実に実施したことを保証してます。デジタル署名を使ってそれぞれのエンティティが内容に承認、署名する仕組みがAP2の一番面白いところと言えるでしょう。

委任状（Mandate）には3種類あり、各シーケンスで必要な情報を送受信します。

#### Intent Mandate

まずはIntent Mandateです。これは、ユーザーの購入意図(Intent)を示すものです。

SAが作成し、ユーザーへ「あなたの購入意図はこうだよね？これでMAに依頼するけどいいかな？」といった具合で確認をとり、確認がとれたらそれをMAに伝えます。

「ユーザーの確認」をとって、と述べましたが、ユーザーの関与の仕方（トランザクションの様式）によってユーザーの署名が必要か署名が不要か変わってきます。トランザクションの様式については後ほど説明します。

今回のデモアプリは、シーケンスの細かいところまで割れているHuman in presentというトランザクションの様式で作成しているため、より革新的な技術であるHuman not in presentはあまりわかっていません。もう少し仕様がわかってきたらこちらも試してみたいと思います。

#### Cart Mandate

次にCart Mandateです。これは、MAが作成してきた商品が入ったカートを指します。

この商品カートが「本当に売っていいものなのか」、「本当に買いたいものなのか」をお店側、ユーザー双方に承認を取ることで購入へと進みます。

こちらもHuman presentとHuman not presentの場合で動きが異なるのですが、Human presentの場合、購入の確定という意味でユーザーの署名が必要になります。一方で、Human not in presentの場合は、Intent Mandateにてユーザーの意図に基づき、購入を自動で遂行する必要があるため、ユーザー署名がこのタイミングで不要な場合がおおいです。

ちなみに、お店側の署名はどのトランザクションでも必要になります。

#### Payment Mandate

最後にPayment Mandateです。これはSAがユーザーに代わって支払いをするうえで必要な委任状でユーザーの署名と支払いに関するトークンが含まれているのが特徴です。

この取引がエージェントによるものであり、どのような認証プロセスを経たかというのがPayment Mandateを見ることでわかるようになっているのでお店の決済処理システムや決済ネットワークに正しくリスクを含めて伝えることができるのが特徴です。

### トランザクションの様式

AP2には主に２つのトランザクションの様式があります。「Human Present (人間がその場にいる決済)」と「Human Not Present (人間がその場にいない決済)」です。ユーザーの関与の仕方が異なります。

#### Human Present

まず、「Human Present」は、ユーザーがAIエージェントにタスクを委任するものの、**最終的な支払いを承認するためにその場にいる（利用可能である）**シナリオに適用されます。イメージとしては、チャットボットと会話しながら商品を選び、買い物を完了させるような動きです。

この場合、ユーザーの意思を否認不可で証明するべきはCart Mandateになります。なぜなら、商品カートを選んで購入するときにユーザーに最終確認を求めることができるためです。なので、Intent Mandateへのユーザー署名は省略することができます。（おそらく署名してもいいのですが、UIUX的にかなり冗長になるのでこのデモアプリでは避けてます。）

#### Human Not Present

「Human Not Present」は、ユーザーがエージェントにタスクを委任し、ユーザーが不在の状況下でエージェントが決済を自律的に実行することを許可するシナリオに適用されます。

例えば、「価格が100ドルを下回ったらこの靴を買う」のようにあらかじめ購入の条件をSAに伝えておいて、SAがその条件になったらユーザー不在のまま購入手続きを進める、というものです。

この場合、ユーザーの意思を否認不可で証明するべきはIntent Mandateになります。なので、「Human Not Present」ではIntent Mandateにユーザー署名が必須となります。逆にCart Mandateに署名要求してしまうと購入まで進められないのでCart Mandateではユーザー署名は不要となります。

とはいえ、実はHuman Not Presentの仕様は公式ドキュメントでまだ詳しくでてないので、その後のPayment Mandateはどう扱うのか。もし不都合な購入が進められてしまった場合の紛争解決はどうするのかなどは存じてません。すみません。

## では作ったものを見ていこう

ドキュメントから得られる自分のAP2に関する知識は正直このレベルなので、実際に作りながら細かい挙動や署名の仕組み、A2Aで実際にやり取りされる内容、UIUXなどを深堀りしていこうと思います。

公式ドキュメントでは「Human Not Present」のシーケンスがなかったのでそちらへは対応してません。

### 構成図

![ig](https://i.imgur.com/KbSA2Lp.png)

とても複雑になってしまいましたが、むしろDocker ComposeのYAMLファイルを見たほうがイメージしやすいかもしれません。抜粋したものを見てみましょう。

```yaml
version: "3.8"

services:
  # Init Keys - キーペア初期化（起動時に1回実行）
  init-keys:
  # Init Seeds - シードデータ投入（起動時に1回実行）
  init-seeds:
  # Shopping Agent - ユーザー向けエージェント
  shopping_agent:
  # Shopping Agent MCP - MCPツール（LangGraphノード）
  shopping_agent_mcp:
  # Merchant Agent - 商品検索・CartMandate作成
  merchant_agent:
  # Merchant Agent MCP - MCPツール（LangGraphノード）
  merchant_agent_mcp:
  # Merchant - CartMandate署名
  merchant:
  # Credential Provider 1 - WebAuthn検証・トークン発行
  credential_provider:
  # Credential Provider 2 - WebAuthn検証・トークン発行（複数CP対応）
  credential_provider_2:
  # Payment Processor - 決済処理
  payment_processor:
  # Payment Network - 決済ネットワーク（Agent Token発行）
  payment_network:
  # Frontend - Next.js
  frontend:
  # Meilisearch - 全文検索エンジン（商品検索用）
  meilisearch:
  # Jaeger - 分散トレーシングバックエンド（OpenTelemetry）
  jaeger:
  # Redis - KVストア（一時データ・セッション管理）
  redis:
```

SAとMAがそれぞれいるのと、SAとユーザーを繋ぐフロントエンドがいます。
また、SA、MAがMandateを作ったり、商品検索を実施するためのツールが独立したMCPサーバーとしてDocker Composeのサービスになっており、StreamableHTTPで利用可能な形となっています。

さらにCP、MPPそして決済ネットワークのスタブサービスが立ち上がります。

各エンティティは固有のDBを持ち、SQLiteで実装されています。一時的なKVストアが必要なときは共通のRedisにアクセスしつつ、DBが各エンティティで分けています。
また、商品検索には全文検索エンジンが適しているためMeilisearchを利用します。

さらに、OpenTelemetryのバックエンドとしてJeagerを導入しました。

すべてのサービスが利用する公開鍵、秘密鍵および、DiDは初期化スクリプトで作成されます。

また、LLMOpsの観点で、Langfuseを導入しています。これによりSAやMAのLangGraphのグラフ構築がだいぶ楽になりました。

### 事前準備

まずは、ユーザーを作成するところからやりましょう。このデモアプリではメールアドレス・パスワードでユーザーを作成します。主にSAとの通信で利用される認証情報となります。もうすこしわかりやすく言えば、お買い物チャットボットの認証といえるでしょう。

それとは別にパスキーの登録画面が入ります。これは、Device Asstationのために利用するものです。厳密には、

パスキーはSAに登録されるのではなく、CPにて管理されます。今回は簡易的にSAとの通信に使うフロントエンドにて登録する形となっています。

さらにクレジットカード情報を登録します。これもSAではなく、CPに登録しているのですが同様の理由で同じフロントエンドから実施しています。（なのでSAはからは見えません）

### フロントエンドの概要

フロントエンドは3つの画面で構成されます。 `/chat` `/merchant` `/payment-methods`です。

`/chat`はユーザーとSAのの間のチャットUIを提供します。`/payment-methods`は先程追加したクレジットカードの編集削除や、追加ができる画面です。CPと通信するため本来は別のドメインになるはずです。　`/merchant` は文字通りお店側の管理画面です。商品管理や注文履歴の管理、お店側の署名を手動で行うなどが可能です。

こちらも本来はお店専用のフロントエンドとなるはずです。

早速、`/chat`からチャットをスタートしましょう！

「こんにちは」とかなにか文字を打つとスタートします。

## SAはLangGraph

突然ですが、SAは[LangGraph](https://www.langchain.com/langgraph)と[Docker Model Runner](https://www.docker.com/ja-jp/products/model-runner/)で動かしてます。Docker Model Runnerを使ったのは、Docker Composeですべての環境が手に入る（ローカルLLMなので）のと、育休中で金がないので検証のために気軽にAPIを叩けないためです。（とても金欠、助けてくれ。）

なので、このデモは無料で試せるのです！その代わりローカルLLM（QWEN3）を使うので全体的に動作はもっさりします。気になる方は、別のモデルを利用していただければと思います。

LangGraphのグラフは次のとおりです。

![graph](https://i.imgur.com/guOh2VY.png)

だいぶ長い+直線的なグラフになっていますが、AP2のシナリオはかなり複雑で署名の順番も重要なので紙芝居的に動きます。どこかエラーになるとエラーノードに移動し、「こんにちは」と入力させてリセットさせる必要があります。

このあたりのグラフにもこだわりたいですが、そうすると時間も足りなくなるのでユーザーのインテントを抽出するところだけLLM（青いところ）を利用し、それ以外は固定の文言で動きます。

例えば工夫の余地があるとしたら、MAからカート情報を受け取ったら一度SA側で推論をかけて、結果を精査した後ユーザーに提示、などもできると思います。

### Intent抽出・Intent Mandate骨子作成(collect_intent)

挨拶ノードは説明をスキップしてまず、重要なのはcollet_intentノードです。ユーザーの購入意図を自然言語で受付け、Intent Mandateの骨子を作成する重要なノードです。

購入意図、予算、キーワード、商品カテゴリー、ブランドなどを抽出します。

![aaa](https://i.imgur.com/W3hZl94.png)


これは公式ドキュメントのシーケンス[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)でいうところのStep1〜3となります。

本来であればStep3でComfirmとなっているのでユーザーにポップアップなどで確認を求める必要がありそうですが、AP2のお買い物は署名の要求で絶えずポップアップがでてしまい体験が非常に悪いので、違ったら「違うよ」とチャットに入力してもらうことを想定して専用のポップアップは避けるようにしてます。

動作ログを見ると、次のようにLLMから必要情報が取り出されていることがわかると思います。

```log
ap2_shopping_agent         | [2025-11-01 00:49:37,548] INFO in services.shopping_agent.langgraph_shopping_flow: [route_by_step] Routing decision
ap2_shopping_agent         |   current_step: ask_intent
ap2_shopping_agent         |   user_input: かわいいグッズがほしい。5000円以内
ap2_shopping_agent         |   is_step_up_completion: False

ap2_shopping_agent         | [2025-11-01 00:50:12,592] INFO in services.shopping_agent.langgraph_shopping_flow: [collect_intent_node] LLM result: {'intent': 'かわいいグッズを購入したい', 'max_amount': 5000, 'keywords': ['かわいい', 'グッズ', 'おしゃれ']}

ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:12.593597Z", "level": "INFO", "logger": "agent", "message": "[_create_intent_mandate] Reconstructed intent: かわいいグッズを購入したい。5000円以内", "module": "agent", "function": "_create_intent_mandate", "line": 1733}

ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:12.593977Z", "level": "INFO", "logger": "agent", "message": "[_build_intent_mandate_from_session] Constructed natural_language_description: かわいいグッズを購入したい。5000円以内", "module": "agent", "function": "_build_intent_mandate_from_session", "line": 1812}

ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:12.594677Z", "level": "INFO", "logger": "agent", "message": "[ShoppingAgent] IntentMandate created (AP2-compliant): intent='かわいいグッズを購入したい...', expiry=2025-11-01T01:50:12.593363Z", "module": "agent", "function": "_build_intent_mandate_from_session", "line": 1824}
```

### 配送先の確定(collect_shipping)

AP2で重要なのは、各Mandateのやり取り時に金額を確定させることです。実は配送料が500円かかりました！とすべての購入が終わってから後出しジャンケンされても困ってしまうためです。そこで、配送先の確定はシーケンスの早い段階で実施します。[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)でいうところのStep5に該当します。

もし、SAがすでに配送先の情報を持っていたら、この処理はSA側で実施できるためシーケンス上はOptionalになっています。

![aaa](https://i.imgur.com/DkjncNI.png)

### CPの選択(select_cp)

Optionalにはなりますが、CPを複数選択することができます。イメージとしては、Google Payでいくか、Paypalでいくか、みたいなものでしょう。（多分）利用可能なCPはあらかじめユーザーが登録しておく必要があるのですが、このデモでは固定で２つのCPを選ぶ形になっています。CPを早い段階で選ぶのは、Step6でCPに対して支払い方法を問い合わせする必要があるためです。[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)でいうところのStep4に該当します。

実装としては、次の支払い方法の確認にスムーズに移れるため、[7.1 Illustrative Transaction Flow](https://ap2-protocol.org/specification/#core-principles)のStep4,5を入れ替えた実装をしています。

![aaa](https://i.imgur.com/UcGRWrS.png)

### 支払い方法の確認(get_payment_method)

CPが決定しているので支払い方法を取得していきます。Human Presentのトランザクション様式なので、実際にユーザーに最終確認するタイミングはシーケンスの後ろですが、このタイミングで内部では取得しておく形となります。これも配送料と同じ理屈で、関連する手数料、割引、またはロイヤルティ情報が選択する支払い方法によって変わってくる可能性があるため、その支払い方法の候補をCart Mandate作成までにMAに提示する必要があるためです。

あくまでも内部的な動作なので画面には出ませんが選択したCPと通信するログが出力されます。

```log
ap2_shopping_agent         | [2025-11-01 00:50:29,045] INFO in services.shopping_agent.langgraph_shopping_flow: [select_cp_node] AP2 Step 4: User selected Credential Provider
ap2_shopping_agent         |   User ID: usr_ee3014bbc51f4156
ap2_shopping_agent         |   CP ID: did:ap2:cp:demo_cp
ap2_shopping_agent         |   CP Name: AP2 Demo Credential Provider
ap2_shopping_agent         | [2025-11-01 00:50:29,255] INFO in services.shopping_agent.langgraph_shopping_flow: [get_payment_methods_node] AP2 Step 6-7: Requesting payment methods from CP
ap2_shopping_agent         |   User ID: usr_ee3014bbc51f4156
ap2_shopping_agent         |   CP ID: did:ap2:cp:demo_cp
ap2_shopping_agent         |   CP URL: http://credential_provider:8003
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.257749Z", "level": "INFO", "logger": "agent", "message": "[ShoppingAgent] Requesting payment methods from Credential Provider (http://credential_provider:8003) for user: usr_ee3014bbc51f4156", "module": "agent", "function": "_get_payment_methods_from_cp", "line": 2316}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.261011Z", "level": "INFO", "logger": "agent", "message": "HTTP Request: GET http://credential_provider:8003/payment-methods", "module": "logger", "function": "log_http_request", "line": 182}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.261495Z", "level": "DEBUG", "logger": "agent", "message": "HTTP_REQUEST_RAW: {\"type\": \"HTTP_REQUEST\", \"method\": \"GET\", \"url\": \"http://credential_provider:8003/payment-methods\", \"headers\": {}, \"body\": null}", "module": "logger", "function": "log_http_request", "line": 193}
ap2_credential_provider    | {"timestamp": "2025-11-01T00:50:29.569821Z", "level": "INFO", "logger": "provider", "message": "[get_payment_methods] Retrieved 1 payment methods for user: usr_ee3014bbc51f4156", "module": "provider", "function": "get_payment_methods", "line": 631}
ap2_credential_provider    | INFO:     172.18.0.9:34006 - "GET /payment-methods?user_id=usr_ee3014bbc51f4156 HTTP/1.1" 200 OK
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.576076Z", "level": "INFO", "logger": "agent", "message": "HTTP Response: 200 (317.37ms)", "module": "logger", "function": "log_http_response", "line": 215}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.576146Z", "level": "DEBUG", "logger": "agent", "message": "HTTP_RESPONSE_RAW: {\"type\": \"HTTP_RESPONSE\", \"status_code\": 200, \"headers\": {\"date\": \"Sat, 01 Nov 2025 00:50:28 GMT\", \"server\": \"uvicorn\", \"content-length\": \"252\", \"content-type\": \"application/json\"}, \"body\": {\"user_id\": \"usr_ee3014bbc51f4156\", \"payment_methods\": [{\"id\": \"pm_e6367cd7\", \"type\": \"basic-card\", \"display_name\": \"Visaカード (****1111)\", \"brand\": \"Visa\", \"last4\": \"1111\", \"requires_step_up\": false, \"billing_address\": {\"country\": \"JP\", \"postal_code\": \"111-1111\"}}]}, \"duration_ms\": 317.3692226409912}", "module": "logger", "function": "log_http_response", "line": 226}
ap2_shopping_agent         | {"timestamp": "2025-11-01T00:50:29.576201Z", "level": "INFO", "logger": "agent", "message": "[ShoppingAgent] Retrieved 1 payment methods from Credential Provider", "module": "agent", "function": "_get_payment_methods_from_cp", "line": 2334}
ap2_shopping_agent         | [2025-11-01 00:50:29,576] INFO in services.shopping_agent.langgraph_shopping_flow: [get_payment_methods_node] AP2 Step 7: Received 1 payment methods from CP
ap2_shopping_agent         |   Payment Methods: ['pm_e6367cd7']
```

CPとの通信はA2Aがいいのか、普通のREST APIがいいのか悩みましたが、ここでは `GET /payment-methods` というREST APIで実装してます。(CPをエージェンティックなエンティティと捉えればA2Aが適している気がしますが、実装していくにつれ、そうには思えなかったので)

ポイントとして、レスポンスにはカードの情報が入りますが、PCIデータ（カード番号そのものやCVCなど）は入っていないことがわかります。

### Intent Mandate送信（fetch_cart）

いよいよIntent MandateをMAに送信します。

実際にA2Aで送信されるIntent Mandate+αは次のようなものになります。(A2Aメッセージを送信する際のhttpxのリクエスト時のデバッグログから抽出)

```json
{
  "type": "HTTP_REQUEST",
  "method": "POST",
  "url": "http://merchant_agent:8001/a2a/message",
  "headers": {},
  "body": {
    "header": {
      "message_id": "a2d45408-afbc-4891-af66-647e82665f25",
      "sender": "did:ap2:agent:shopping_agent",
      "recipient": "did:ap2:agent:merchant_agent",
      "timestamp": "2025-11-01T00:50:29.785905Z",
      "nonce": "cc624e26345bfe79c092580578dbba04a14f46c27d44077b2d89303a35970833",
      "schema_version": "0.9",
      "proof": {
        "algorithm": "ed25519",
        "signatureValue": "aMCMUarSscFWY8/j+NKdKflvyzdMjpZHJJqGXuKWsW/XqO0loXpUIfrFFTBzenXXPAajkw7IpQYMWtv4ytyNDg==",
        "publicKeyMultibase": "z6MkwMTmaSbsecH3zoTBSAEY2vuMxguAebRnruND2a8oVvcq",
        "kid": "did:ap2:agent:shopping_agent#key-2",
        "created": "2025-11-01T11:42:36.177985Z",
        "proofPurpose": "authentication"
      },
      "signature": null
    },
    "dataPart": {
      "@type": "ap2.mandates.IntentMandate",
      "id": "intent_a97064a3",
      "payload": {
        "intent_mandate": {
          "id": "intent_a97064a3",
          "type": "IntentMandate",
          "user_id": "usr_ee3014bbc51f4156",
          "user_cart_confirmation_required": true,
          "natural_language_description": "かわいいグッズを購入したい。5000円以内",
          "requires_refundability": false,
          "intent_expiry": "2025-11-01T01:50:12.593363Z",
          "created_at": "2025-11-01T00:50:12.593363Z"
        },
        "shipping_address": {
          "recipient": "山田太郎",
          "postal_code": "123-4567",
          "city": "豊島区",
          "region": "東京都",
          "address_line1": "北大塚1-1-1",
          "country": "日本"
        }
      },
      "kind": null,
      "artifact": null
    }
  }
}
```

まずわかりやすくIntent Mandateそものもから見ていきましょう。

```json
{
  "id": "intent_a97064a3",
  "type": "IntentMandate",
  "user_id": "usr_ee3014bbc51f4156",
  "user_cart_confirmation_required": true,
  "natural_language_description": "かわいいグッズを購入したい。5000円以内",
  "requires_refundability": false,
  "intent_expiry": "2025-11-01T01:50:12.593363Z",
  "created_at": "2025-11-01T00:50:12.593363Z"
},
```

~残念ながら、公式ドキュメントそのものにはIntent Mandateの例が載っていないのですが~、公式のGitHubにある[型定義](https://github.com/google-agentic-commerce/AP2/blob/f404a8ddf2e2a5ddf76a6f3fd990b4cb78a71200/src/ap2/types/mandate.py#L32C7-L32C20)を見ると仕様が見えてきます。重要な項目について見ていきましょう。

(公式ドキュメント [A2A Extension for AP2](https://ap2-protocol.org/a2a-extension/#intentmandate-message)に記載がありました。)

#### user_cart_confirmation_required

こちらは、型定義を見ると

> If false, the agent can make purchases on the user's behalf once all purchase conditions have been satisfied. This must be true if theintent mandate is not signed by the user.

とあるので、Intent Mandateにユーザー署名がない、つまりHuman Presentのトランザクション様式では`true`である必要があります。

#### natural_language_description

今回のデモアプリでは、そこまでSAが意図の深堀りをするシナリオになっていないため、「かわいいグッズを購入したい。5000円以内」というユーザーの入力そのものが入っているが、こちらも型定義を見ると

> The natural language description of the user's intent. This is generated by the shopping agent, and confirmed by the user. The goal is to have informed consent by the user.

とあるので、本来はユーザーのテキストそのものが入るのではなく、SAによって解釈された意図が自然言語として入る形です。また、その意図は確認を求める必要がある、というのも明記されています。

#### intent_expiry

Intent Mandateには有効期限があります。これは、時間的な制限を設けることでユーザーの意図が確かに有効であることを保証するためです。

今回は作成後1時間で設定してますが、Human Not Presentの場合はもう少し伸びる気がします。

#### shipping_address

Intent Mandate自体ではないですが、CartをMAが金額もドンピシャで作成するためにshipping_addressも連携しています。AP2の思想を考えると同様に支払い情報も連携する必要がありそうですがこのデモでは省略しています。

#### SAの署名

Intent Mandateそのものとは別に、謎のHeaderというプロパティがありますが、これは、[W3C Verifiable Credentials](https://www.w3.org/TR/vc-data-model-2.0/)のproof構造を踏襲したもので、SAのVerifiable Presentation (VP) に相当するものです。

公式ドキュメントで明確な文献がなかったのですが、[Paypalのブログ](https://developer.paypal.com/community/blog/PayPal-Agent-Payments-Protocol/)によると

> All mandates are expressed as W3C Verifiable Credentials, ensuring tamper resistance, portability, and interoperability across the ecosystem. Mandates embed cryptographically verifiable consent into authorization flows, providing merchants with dispute-grade evidence, issuers with consistent agent-presence signals and consumers with non-repudiable proof of intent.  

とあるため、その仕様に準拠するように作成しました。

具体的には、proof 仕様（RFC 8032 Ed25519）に基づき、メッセージ全体に対して署名付けを行ってます。

署名のアルゴリズムはSAの秘密鍵を使って、ED25519でDatapartをcanonicalized JSON（RFC8785）で署名をつけるようにします。署名の検証のために使う公開鍵はpublicKeyMultibaseで添付されています。先頭文字が`z`であるため、base58btc（主にDIDで使う）を使っていることがわかります。

また、署名の再送や差し替えを防止するためにnonceも生成してます。

このように、署名なども含め様々な処理が入ってやっとIntent MandateをMAに送ることができるのです。

## MAもLangGraph

さて、Intent MandateがMAに送信されましたのでMAが商品カートを作る作業に移ります。

MAもLangGraphで作成されています。こちらはSAからのIntent Mandateを受け取るところからスタートします。

![graph](https://i.imgur.com/Rt5kgtK.png)

### Graphの開始前に署名の検証

LangGraphのグラフには表現されませんが、（デモではA2Aのメッセージハンドラー上で実施しているため）受け取ったA2Aメッセージが本当にSAから実施しているか検証するためにいくつかの検証が入ります。

```log
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.410065Z", "level": "DEBUG", "logger": "v2.common.a2a_handler", "message": "[A2AHandler] Nonce validation successful: nonce=3be7627de7fda009...", "module": "a2a_handler", "function": "verify_message_signature", "line": 156}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.477476Z", "level": "DEBUG", "logger": "v2.common.a2a_handler", "message": "[A2AHandler] Using DID-resolved public key for verification: kid=did:ap2:agent:shopping_agent#key-2", "module": "a2a_handler", "function": "verify_message_signature", "line": 192}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.490047Z", "level": "DEBUG", "logger": "common.crypto", "message": "Verifying A2A message signature", "module": "crypto", "function": "verify_a2a_message_signature", "line": 1037}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.503860Z", "level": "DEBUG", "logger": "common.crypto", "message": "[VERIFY] Canonical JSON length: 797, first 200 chars: {\"dataPart\":{\"@type\":\"ap2.mandates.IntentMandate\",\"id\":\"intent_4956d1e9\",\"payload\":{\"intent_mandate\":{\"created_at\":\"2025-11-01T11:42:11.403084Z\",\"id\":\"intent_4956d1e9\",\"intent_expiry\":\"2025-11-01T12:4", "module": "crypto", "function": "verify_a2a_message_signature", "line": 1041}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.503901Z", "level": "DEBUG", "logger": "common.crypto", "message": "Verifying signature (algorithm: ED25519)", "module": "crypto", "function": "verify_signature", "line": 871}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.513250Z", "level": "INFO", "logger": "common.crypto", "message": "Crypto VERIFY: ED25519 (key: did:ap2:agent:shopping_agent#key-2) - SUCCESS", "module": "logger", "function": "log_crypto_operation", "line": 350}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.513851Z", "level": "INFO", "logger": "v2.common.a2a_handler", "message": "[A2AHandler] proof署名検証成功: sender=did:ap2:agent:shopping_agent, alg=ed25519, kid=did:ap2:agent:shopping_agent#key-2, public_key_source=DID-resolved", "module": "a2a_handler", "function": "verify_message_signature", "line": 223}
ap2_merchant_agent         | {"timestamp": "2025-11-01T11:42:36.514061Z", "level": "INFO", "logger": "v2.common.a2a_handler", "message": "[A2A処理] ハンドラー実行中: type=ap2.mandates.IntentMandate, from=did:ap2:agent:shopping_agent", "module": "a2a_handler", "function": "handle_message", "line": 305}
```

#### リプレイ攻撃の対策

まず、proof構造が正しいかのチェックをしたあと、Timestamp検証を実施します。これは仕組みは単純で現在時刻から300秒=5分以内に作成されたproofかを確認します。リプレイ攻撃を避けるための基本的な対策にはなります。

また、Nonce検証も実施します。再利用を確認し、単位時間（ここでは300秒=5分)以内に同じNonceを利用していないことを確認します。

#### 公開鍵の取得

さてproof構造からメッセージの署名を検証していきます。まず、署名の検証のためにはSAの公開鍵が必要になります。こちらの公開鍵を取得する方法として、AP2ではDID（Decentralized Identifier／分散型識別子）を使う方法が推奨されていますが、デモアプリではpublicKeyMultibaseを使う方法も合わせてサポートしています。DIDについて馴染みもないと思いますので詳しく見ていきましょう。

##### そもそもDIDとは？

DID（Decentralized Identifier／分散型識別子）は文字通り、分散型（中央集権的な仕組みでない）エンティティを識別する方法です。

署名の検証はproof構造を持ったA2A通信であれば、publicKeyMultibaseに保存されているため、送られたメッセージが途中で改ざんされずに通信を完了したことは判断できます。

しかし欠点として、「鍵」だけでは“誰の鍵か”がわからないという問題があります。おそらく送信先からSAということはわかるのですが、SAがどんなエージェントなのか、詳しいことはわかりません。DIDを使って“信頼の文脈”を作ることができます。

DIDでは`did.json`というJSONファイルを各エンティティの`.well-known/did.json`からアクセスできるようにすることから始めます。例えばSAのdid.jsonは次のとおりです。

```json
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://w3id.org/security/suites/jws-2020/v1",
    "https://w3id.org/security/suites/ed25519-2020/v1"
  ],
  "id": "did:ap2:agent:shopping_agent",
  "verificationMethod": [
    {
      "id": "did:ap2:agent:shopping_agent#key-1",
      "type": "EcdsaSecp256r1VerificationKey2019",
      "controller": "did:ap2:agent:shopping_agent",
      "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEPlqNMbMKh/8HoX2356uZmKM2lVuB\nY71rBhcg1lpuUBncM7LmNAEJO/9WcKboqL+KHKpwGCIEr/oWsizgd89hvA==\n-----END PUBLIC KEY-----\n",
      "publicKeyMultibase": "z2oAtKWnMsubf5MPr6XqWVuLeXVipQ84i4jj2VV9Vu5EZjtQ8"
    },
    {
      "id": "did:ap2:agent:shopping_agent#key-2",
      "type": "Ed25519VerificationKey2020",
      "controller": "did:ap2:agent:shopping_agent",
      "publicKeyPem": "-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEAkr3srUb1CmKJq6G0h0PXPnOUtJrTQKL/a8u0J3Ob1wk=\n-----END PUBLIC KEY-----\n",
      "publicKeyMultibase": "z6MkpL5YFLHxAcp6LSJboXQ3nBnNGrQ4TiZRmWBZamPo7t8x"
    }
  ],
  "authentication": [
    "did:ap2:agent:shopping_agent#key-1",
    "did:ap2:agent:shopping_agent#key-2"
  ],
  "assertionMethod": [
    "did:ap2:agent:shopping_agent#key-1",
    "did:ap2:agent:shopping_agent#key-2"
  ],
  "created": "2025-11-02T00:16:30.663059Z",
  "updated": "2025-11-02T00:16:30.663091Z",
  "service": [
    {
      "id": "did:ap2:agent:shopping_agent#a2aendpoint",
      "type": "A2AEndpoint",
      "serviceEndpoint": "http://shopping_agent:8000/a2a",
      "name": "Shopping Agent A2A Endpoint",
      "description": "A2A通信エンドポイント（ユーザー購買代理エージェント）"
    }
  ]
}
```

`did.json`から公開鍵を取得することで、メッセージの署名主が確実にSAであることを示すことができるわけです。ちなみに、AP2におけるDIDのリゾルバーの標準仕様はよくわからず、今回はID `did:ap2:agent:shopping_agent` からDocker Network上のホスト名を取得して、`.well-known/did.json`にアクセスする仕組みを取ってます。

##### publicKeyMultibase

おそらくAP2的にはあまり推奨されないのですが、proof構造に含まれるpublicKeyMultibaseを使った署名の検証もデモアプリではサポートしています。一応、DIDを優先して実施するようにはしてますし、DIDが前提のアーキテクチャの場合、proof構造にpublicKeyMultibaseを入れることは不要なのかもしれません。

#### 検証

いよいよ検証に入ります。ED25519でDatapartをcanonicalized JSON（RFC8785）で署名されたことはわかっていますので、公開鍵を使って検証を実施します。

無事に検証が完了したらSAから確かに送られてきたMandateとわかるので次の処理に移ります。

### Intent MandateからIntentを抽出(analyze_intent)

受け取ったIntent Mandateの`natural_language_description`からキーワードや価格などを抽出してDBに検索できる情報に落とし込む処理をLLMの力を使って実施してます。

次のようなプロンプトが動きます。

```
=========System Prompt==========
あなたはMerchant Agentのインテント分析エキスパートです。
ユーザーのIntentMandate（購入意図）を解析し、以下の情報を抽出してください:

primary_need: ユーザーの主な要求（1文で簡潔に、日本語）
budget_strategy: 予算戦略（"low"=最安値優先、"balanced"=バランス型、"premium"=高品質優先）
key_factors: 重視する要素のリスト（例: ["品質", "価格", "ブランド", "デザイン"]）
search_keywords: 商品検索用のキーワードリスト（日本語、3-5個、商品名に含まれそうな単語）
重要:

search_keywordsは必ず日本語で返してください（例: ["かわいい", "グッズ", "Tシャツ"]）
商品データベースは日本語の商品名（例: "むぎぼーTシャツ", "むぎぼーマグカップ"）なので、日本語キーワードが必須です
必ずJSON形式で返答してください。

=========User Prompt===========
以下のIntentMandateを分析してください:

自然言語説明: かわいいグッズを購入したい。5000円以内
制約条件: {}

JSON形式で返答してください（search_keywordsは必ず日本語）:
{
"primary_need": "...",
"budget_strategy": "low/balanced/premium",
"key_factors": ["...", "..."],
"search_keywords": ["...", "...", "..."]
}
```

今回は育休中でお金がないので、ローカルLLMを使っているためそこまでIntentを正しく抽出できていない気がしますが、きっと最新モデルだともう少しちゃんと出るはずです。

```json
{
    "role": "assistant",
    "content": {
        "primary_need": "かわいいグッズを5000円以内で購入したい",
        "budget_strategy": "low",
        "key_factors": [
            "価格",
            "デザイン"
        ],
        "search_keywords": [
            "かわいい",
            "グッズ",
            "小物"
        ]
    },
    "additional_kwargs": {
        "refusal": null
    }
}
```

### MCPサーバー経由で商品検索DBへ検索(search_products)

AP2はA2A、MCPと対立する技術ではなく、拡張するもの、ということが公式ドキュメントでも強調されています。そこで、今回は商品検索のツール利用はMCPサーバーを利用することにしました。（Streamable HTTP）

商品検索そのものは全文検索エンジンを使いたかったので軽量なmelisearchを使っています。

Initialize処理などを省略しますが、　`tools/call`で次のようなリクエストをMAからMAが使うMCPサーバーへ飛ばしていることがわかります。

```json
{
  "type": "HTTP_REQUEST",
  "method": "POST",
  "url": "http://merchant_agent_mcp:8011/",
  "headers": {
    "Content-Type": "application/json",
    "Mcp-Session-Id": "2ade50e5-f2ae-439c-becb-0ba97bd1a161"
  },
  "body": {
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
      "name": "search_products",
      "arguments": {
        "keywords": [
          "かわいい",
          "グッズ",
          "安価"
        ],
        "limit": 20
      }
    },
    "id": 387151
  }
}
```

結果は次のように返ってきます。商品のIDはRDB（SQLite）にある商品IDと一致しています。

```json
{
  "type": "HTTP_RESPONSE",
  "status_code": 200,
  "headers": {
    "date": "Sun, 02 Nov 2025 00:21:39 GMT",
    "server": "uvicorn",
    "content-length": "3086",
    "content-type": "application/json"
  },
  "body": {
    "jsonrpc": "2.0",
    "id": 387151,
    "result": {
      "content": [
        {
          "type": "text",
          "text": "{\"products\": [{\"id\": \"286acdd4-d1c1-4860-b06a-f87d2f916a8d\",\"sku\": \"MUGI-KEYCHAIN-001\",\"name\": \"むぎぼーアクリルキーホルダー\",\"description\": \"かわいいむぎぼーのアクリルキーホルダー。バッグやポーチに付けて持ち歩けます。\",\"price_cents\": 80000,\"price_jpy\": 800.0,\"inventory_count\": 100,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"9f58d67c-5c45-4cd4-bf10-73f06647c234\",\"sku\": \"MUGI-CLOCK-001\",\"name\": \"むぎぼー時計\",\"description\": \"むぎぼーデザインのかわいい壁掛け時計。お部屋を明るく彩ります。\",\"price_cents\": 350000,\"price_jpy\": 3500.0,\"inventory_count\": 30,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"2faf8370-ada4-45d4-812c-ef5818d526b5\",\"sku\": \"MUGI-POUCH-001\",\"name\": \"むぎぼーポーチ\",\"description\": \"むぎぼー柄のかわいいポーチ。小物入れやペンケースとして使えます。\",\"price_cents\": 95000,\"price_jpy\": 950.0,\"inventory_count\": 120,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"1d9f08d9-51a9-491e-810b-f0e225ef4f59\",\"sku\": \"MUGI-MUG-001\",\"name\": \"むぎぼーマグカップ\",\"description\": \"むぎぼーがプリントされたかわいいマグカップ。毎日のティータイムが楽しくなります。\",\"price_cents\": 120000,\"price_jpy\": 1200.0,\"inventory_count\": 80,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"c688d6ef-615f-43f7-87ce-05568ae4e63c\",\"sku\": \"MUGI-SOCKS-001\",\"name\": \"むぎぼー靴下\",\"description\": \"むぎぼーがワンポイントで入ったかわいい靴下。やわらかい履き心地。\",\"price_cents\": 85000,\"price_jpy\": 850.0,\"inventory_count\": 100,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30},{\"id\": \"6a169d3a-ca5a-4575-a08b-3fb659c628ed\",\"sku\": \"MUGI-PLATE-001\",\"name\": \"むぎぼープレート皿\",\"description\": \"むぎぼーが中央に描かれた陶器プレート。食卓をかわいく演出。\",\"price_cents\": 190000,\"price_jpy\": 1900.0,\"inventory_count\": 70,\"category\": null,\"brand\": null,\"image_url\": null,\"refund_period_days\": 30}]}"
        }
      ],
      "isError": false
    }
  },
  "duration_ms": 1208.6033821105957
}
```

### 在庫チェック(check_inventory)

商品が検索できたらその商品の在庫状況をまたMCPサーバー経由で問い合わせます。こちらはRDB（SQLite）への問い合わせですが、search_productsと同様SteamableHTTPでの通信なので詳細は割愛します。次のような各商品の在庫状況を取得します。

```json
{
  "3446cca8-fe68-4354-a518-63eb3e47d27f": 100,
  "1530a7db-6b7a-458e-b7b9-f510f6fdaa89": 30,
  "cf08568b-8115-461c-aa7e-5a2e07bf4476": 120,
  "e534386f-c89b-4548-9734-78bd34958f88": 80,
  "eb0e5de8-679d-4445-8e64-a1d4d40097fd": 100,
  "f0f41c9f-a31d-4a88-a180-96149a9057fc": 70
}
```

### カート作成(optimize_cart)

いよいよカートの作成を実施します。ローカルLLMに3つのカートプランを作成してもらうノードとなります。

次のようなプロンプトが走ります。

```
========System Prompt=========
あなたはMerchant Agentのカート最適化エキスパートです。
ユーザーの購入意図と商品リストから、最適なカートプラン3つを提案してください。

各プランには以下を含めてください:

name: プラン名（予算や特徴を含む、例: "予算内プラン (5,000円)"）
description: プランの説明（1-2文）
items: 商品リスト [{"product_id": 123, "quantity": 1}, ...]
プラン設計のガイドライン:

プラン1: 予算内で最もコスパが良いプラン
プラン2: 予算を少し超えても高品質なプラン
プラン3: シンプルに1-2商品のみのプラン
必ずJSON配列形式で返答してください。

=======User Prompt============
以下の条件でカートプランを3つ提案してください:

ユーザーの要求: かわいいグッズを5000円以内で購入したい
予算戦略: low
重視要素: 価格, デザイン
予算上限: 指定なし

商品リスト（6件）:
[
  {
    "id": "3446cca8-fe68-4354-a518-63eb3e47d27f",
    "name": "むぎぼーアクリルキーホルダー",
    "price_jpy": 800.0,
    "category": null,
    "inventory": 100
  },
  {
    "id": "1530a7db-6b7a-458e-b7b9-f510f6fdaa89",
    "name": "むぎぼー時計",
    "price_jpy": 3500.0,
    "category": null,
    "inventory": 30
  },
  {
    "id": "cf08568b-8115-461c-aa7e-5a2e07bf4476",
    "name": "むぎぼーポーチ",
    "price_jpy": 950.0,
    "category": null,
    "inventory": 120
  },
  {
    "id": "e534386f-c89b-4548-9734-78bd34958f88",
    "name": "むぎぼーマグカップ",
    "price_jpy": 1200.0,
    "category": null,
    "inventory": 80
  },
  {
    "id": "eb0e5de8-679d-4445-8e64-a1d4d40097fd",
    "name": "むぎぼー靴下",
    "price_jpy": 850.0,
    "category": null,
    "inventory": 100
  },
  {
    "id": "f0f41c9f-a31d-4a88-a180-96149a9057fc",
    "name": "むぎぼープレート皿",
    "price_jpy": 1900.0,
    "category": null,
    "inventory": 70
  }
]

JSON配列形式で返答してください:
[
  {
    "name": "プラン名（価格含む）",
    "description": "プラン説明",
    "items": [{"product_id": 123, "quantity": 1}]
  },
  ...
]
```

残念ながらローカルLLMの性能だと、本当に最適なプランを出してきてくれないこともありますし、JSONが不完全なこともあるのですが....。うまくいくと次のようなJSONが出力されます。

```
[
    {
        "name": "コスパ最強プラン (1,650円)",
        "description": "価格重視で最安値のキーホルダーと靴下を組み合わせたプラン。かわいさと予算を両立させます。",
        "items": [
            {
                "product_id": "286acdd4-d1c1-4860-b06a-f87d2f916a8d",
                "quantity": 1
            },
            {
                "product_id": "c688d6ef-615f-43f7-87ce-05568ae4e63c",
                "quantity": 1
            }
        ]
    },
    {
        "name": "高品質プラン (2,150円)",
        "description": "かわいさを重視してポーチとマグカップを組み合わせたプラン。品質とデザインのバランスが良いです。",
        "items": [
            {
                "product_id": "2faf8370-ada4-45d4-812c-ef5818d526b5",
                "quantity": 1
            },
            {
                "product_id": "1d9f08d9-51a9-491e-810b-f0e225ef4f59",
                "quantity": 1
            }
        ]
    },
    {
        "name": "シンプルプラン (800円)",
        "description": "予算を抑えたい方におすすめのキーホルダー単品プラン。かわいらしさを最大限に活かした1点です。",
        "items": [
            {
                "product_id": "286acdd4-d1c1-4860-b06a-f87d2f916a8d",
                "quantity": 1
            }
        ]
    }
]
```