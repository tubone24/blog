---
slug: 2023/01/01/this-blog
title: 2023年版このブログを支える技術その1(Gatsby.jsと取り巻く技術要素)
date: 2023-01-01T02:00:29.202Z
description: 2022年版をやってないのにシリーズ恒例にしようとしている
tags:
  - Gatsby.js
  - TypeScript
  - Bootstrap
  - Sass
  - Netlify
headerImage: https://i.imgur.com/18P6Wlz.png
templateKey: blog-post
---

2023年はもっといい年にしたいですね。

## Table of Contents

```toc

```

## あけましておめでとうございます〜

あけましておめでとうございます。本年もよろしくおねがいします。

![eto usagi](https://i.imgur.com/cRHAJbol.png)

本年こそは何かを成し遂げたい私ですが、2017年からこまごま続けているこのブログの**技術スタック**についてもだいぶ固まってきた気がするので新年早々まとめ記事を書いていこうかと思います。

## はじめに

このブログのソースコード、記事のMarkdownなどはすべて[GitHub](https://github.com/tubone24/blog)で管理してます。

そこに載っているReadmeをみればある程度やっていることがわかるようにはなっているのですが、せっかくなので、**どうしてその技術スタックなのか**などの深堀りもできたらなぁーと思ってます。

## 基本的な技術

本ブログは2019年からGatsby.jsを使ったSSGで構築されています。それまではWordpressでした。フロントエンドの技術がさっぱりわからず、いよいよ危機感を感じたところからブログでも作ってみるか〜というノリで作り始めたと思います。

ブログ記事はMarkdownで管理し、GitHubへのPushおよびPull Requestのイベント契機でGitHub Actionsが静的サイトを作成する仕組みです。これもいくつかの技術変遷がありました。

ホスティングはNetlifyを使ってます。これは当初から変えてません。浮気しようと思ったこともあるんですけどね。

## Why Gatsby?

SSGでサイトを作るなら例えばNext.jsだったり、Hugo、最近だとAstroなんかも流行ってますし、Vue.jsのフレームワークになれているならvuepress、Denoで作りたければlumeなんかの選択肢も上がってきます。

そのなかでなぜにGatsbyがこのブログで採用され続けているかというと、サイトを作り込み過ぎて移行コストがドエライからです。いわゆるサンクコストというやつです。

こと、SSGの分野でGatsbyが何となく最近他のフレームワークに押されているのってなんとなくGraphQLを常に意識させ続けられる開発体験がちょっと辛くなる瞬間、特にReactのコンポーネント書いていると裏そばにいるGraphQLにべったり依存しているナ〜というあの感覚が嫌いで使わなくなっていく人が多い印象がありますが、

何年も運用しているともはや慣れっこになってしまいました。GraphQL最高！　GraphQL最高！オマエもGraphQL最高と叫びなさい‼︎

![mirai saikou](https://i.imgur.com/Cv8jtrol.jpg)

というのは冗談で、データソースをある意味GraphQLが媒介してくれるので、データソースに依存しないサイトを作ることはできるのは事実あります。別にNext.jsでもgetStaticPropsとかでMarkdown読み込みの依存度を減らしてあげるような作り方は全然できると思いますが、何も考えずに作れるのがGatsbyのいいところではないでしょうか？

### プラグインがだいたいなんとかしてくれる

これです。コミュニティーが成熟し、自分で実装しなくていいことがだいたいプラグインで用意されてます。

だいたいのプラグインはnpm installしてgatsby-config.jsに定義してあげるだけです。楽ちん。

使っているプラグインを列挙すると次のものがありました。結構使ってますね。

- [gatsby-plugin-preact](https://www.gatsbyjs.com/plugins/gatsby-plugin-preact/)
  - 後述します。Reactの軽量版の[Preact](https://preactjs.com/)が使えるようになんかごにょごにょやってくれるやつ。プラグインを入れるだけでよかったので優秀。
- [gatsby-plugin-typegen](https://www.gatsbyjs.com/plugins/gatsby-plugin-typegen/)
  - 後述します。GatsbyをTypeScript化するときに、GraphQLの型を自動生成します。
  - 内部的には[GraphQL Code Generator](https://the-guild.dev/graphql/codegen)を使って.graphqlファイルからtypes.tsを作る感じです。
- [gatsby-plugin-exclude](https://www.gatsbyjs.com/plugins/gatsby-plugin-exclude/)
  - 後述します、Storybook対応の際に一部のxxx.stories.tsxをbuildの際に読み込んでしまう問題があったため、対象から除外する目的で導入してます。
- [gatsby-plugin-react-helmet](https://www.gatsbyjs.com/plugins/gatsby-plugin-react-helmet/)
  - 超定番プラグイン。各Page, TemplateごとにHeadタグを作りたいときに便利です。ブログサイトだとSEOを意識させられるので必須ですね。
- [gatsby-plugin-react-helmet-canonical-urls](https://www.gatsbyjs.com/plugins/gatsby-plugin-react-helmet-canonical-urls/)
  - react-helmetでcanonicalをつけてくれるプラグイン。SEO対策。
- [gatsby-plugin-sass](https://www.gatsbyjs.com/plugins/gatsby-plugin-sass/)
  - 後述します。このブログのStyleはSass(Scss)で管理されています。
- [gatsby-plugin-minify-classnames](https://www.gatsbyjs.com/plugins/gatsby-plugin-minify-classnames/)
  - SassをCSS modulesで使うと長くなりがちなclass nameをproduction build時に短くしてサイズをちっちゃくしてくれます。
- [gatsby-plugin-purgecss](https://www.gatsbyjs.com/plugins/gatsby-plugin-purgecss/)
  - 後述します、CSSフレームワークとして使っているBootstrapが重たいので少しでも小さくするために使ってます。
- [gatsby-remark-copy-linked-files](https://www.gatsbyjs.com/plugins/gatsby-remark-copy-linked-files/)
  - このブログではあんまり使ってませんが、ファイルを公開するときによしなにpublicからのリンクを作ってくれます。
- [gatsby-plugin-webpack-bundle-analyser-v2](https://www.gatsbyjs.com/plugins/gatsby-plugin-webpack-bundle-analyser-v2/)
  - Webpackのバンドルサイズを確認します。後述しますが、めちゃくちゃでかい..。
- [gatsby-source-filesystem](https://www.gatsbyjs.com/plugins/gatsby-source-filesystem/)
  - ファイルとして保存されているMarkdownをGraphQLとして読み込み、記事化するために必要なデータソースプラグインです。Markdownをデータソースにしている場合、ほぼ必須のプラグインだと思います。
- [gatsby-plugin-robots-txt](https://www.gatsbyjs.com/plugins/gatsby-plugin-robots-txt/)
  - SEO対策です。後述するPreview Deployの場合、そちらをGoodleにIndexされないように制御もしてます。
- [gatsby-plugin-feed](https://www.gatsbyjs.com/plugins/gatsby-plugin-feed/)
  - RSSを生成してくれます。
- [gatsby-plugin-algolia](https://www.gatsbyjs.com/plugins/gatsby-plugin-algolia/)
  - 後述します。ブログ内検索として[Algolia](https://www.algolia.com/)を使ってます。Preview Deploy時にIndexされないように制御しています。
- [gatsby-transformer-remark](https://www.gatsbyjs.com/plugins/gatsby-transformer-remark/)
  - MarkdownのRemarkをやってくれるプラグインです。
- [gatsby-remark-numbered-footnotes](https://www.gatsbyjs.com/plugins/gatsby-remark-numbered-footnotes/)
  - あまり使えてませんが脚注を入れるのに使ってます。
- [gatsby-remark-prismjs-title](https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs-title/)
  - [Prismjs](https://prismjs.com/)でシンタックスハイライトしたコードブロックにタイトルを付けるときに使います。
- [gatsby-remark-prismjs](https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs/)
  - [Prismjs](https://prismjs.com/)を使ってコードブロックをシンタックスハイライトします。技術ブログには必須ですね。
- [gatsby-remark-autolink-headers](https://www.gatsbyjs.com/plugins/gatsby-remark-autolink-headers/)
  - 記事内のh1,h2とかにアンカーをつけてくれる。技術記事は引用が多そうなのでつけています。
- [gatsby-remark-external-links](https://www.gatsbyjs.com/plugins/gatsby-remark-external-links/)
  - 外部リンクを別タブで開かせるためにつけてます。 `noopener noreferrer` 忘れずに。
- [gatsby-remark-check-links](https://www.gatsbyjs.com/plugins/gatsby-remark-check-links/)
  - サイト内リンク切れを防止するプラグインです。今までこちらの動作に引っかかったbuildが一度もないので、使っているかと言えばつかっていないかもです。
- [gatsby-plugin-layout](https://www.gatsbyjs.com/plugins/gatsby-plugin-layout/)
  - いわゆるWFのLayout(共通的な側を作る)機能です。このブログでは、全ページで表示されるNavbarの実装とページ遷移時のトランジションの実装で使ってます。 
- [gatsby-plugin-sitemap](https://www.gatsbyjs.com/plugins/gatsby-plugin-sitemap/)
  - サイトマップを作ります。SEO対策ですね。
- [gatsby-plugin-nprogress](https://www.gatsbyjs.com/plugins/gatsby-plugin-nprogress/)
  - ページ遷移時にprefetchされていないpage-data.jsonがあった場合、ロードが発生してしまうので、そこで出すグルグルを出してます。出てくる場面が少ないほうがよいですね。
- [gatsby-plugin-optimize-svgs](https://www.gatsbyjs.com/plugins/gatsby-plugin-optimize-svgs/)
  - SVGの最適化をしてくれるプラグインです。だいたい50%くらい削れているそうです。
- [gatsby-plugin-manifest](https://www.gatsbyjs.com/plugins/gatsby-plugin-manifest/)
  - PWAのマニフェストファイルを作ってくれます。モバイルからのアクセスも結構あったりしますのでPWAは重要です。きっと...。
- [gatsby-plugin-minify](https://www.gatsbyjs.com/plugins/gatsby-plugin-minify/)
  - いわゆるminify系のプラグイン。ビルドされた成果物をとことん読みにくくしてくれる代わりにサイズを小さくしてくれます。1%くらい小さくなっているっぽいです。
- [gatsby-plugin-offline](https://www.gatsbyjs.com/plugins/gatsby-plugin-offline/)
  - Service Worker対応をかんたんに実装してくれます。[gatsby-plugin-manifest](https://www.gatsbyjs.com/plugins/gatsby-plugin-manifest/)と合わせればモバイルの場合、アプリっぽい実装が実現できます。(このブログでその必要があるのか疑問ですが...)
- [gatsby-plugin-netlify](https://www.gatsbyjs.com/plugins/gatsby-plugin-netlify/)
  - Netlifyが解釈できる_headersファイルの生成を行ってます。主にCache Controlを定義しており、できるだけCacheを見てもらう感じで攻めます。

### GatsbyのcreatePagesを制すれば結構自由度が高い

Gatsbyでは、[gatsby-node.js](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/)で動的ページを作成する処理をGatsby Node.js APIを使って定義します。

しかも、これが結構優秀でただMarkdownを読み込んでHTMLをPropsとしてTemplateに渡すのではなく、独自にcontextを生成し、Propsで渡すことができます。

一例ですが、このブログの[createPages](https://github.com/tubone24/blog/blob/master/gatsby/CreatePages.ts)では、[lazy-load(lozad)](https://apoorv.pro/lozad.js/)系のdata-src置換と文字数カウントをcreatePages時、つまりbuild時に実施するようにしてます。

なるべく、Reactが処理するコード量を小さくしてあげ、必要な情報をcontext経由で渡してあげることで、ページ遷移時のレンダリングコストを小さくできると信じてます。

もはや自己満足の世界です。可読性は大きく損ねるしバグの温床なのであまりおすすめはしません。Reactで処理させたり、Markdownで直接定義したほうが100倍わかりやすいです。はい。

```typescript
import path from "path";
import { GatsbyNode } from "gatsby";
import createPaginatedPages from "gatsby-paginate";

export const createPages: GatsbyNode["createPages"] = async ({
  graphql,
  actions: { createPage },
}) => {
    const repHtml = html.replace(
      /<img[\s|\S]src=/g,
      '<img class="lozad" src="data:image/gif;base64,R0lGODlhAQABAGAAACH5BAEKAP8ALAAAAAABAAEAAAgEAP8FBAA7" data-src='
    );
    const words = repHtml
      .replace(/<code[\s, \S]*?<\/code>/g, "")
      .replace(/<("[^"]*"|'[^']*'|[^'">])*>/g, "")
      .replace(/\s+/g, "")
      .replace(/#x.*;/, "")
      .replace(/&/, "").length;
    const minutes = Math.ceil(words / 400);

    const component = templateKey || "blog-post";
    createPage({
      path: $path,
      component: path.resolve(`src/templates/${String(component)}.tsx`),
      // additional data can be passed via context
      context: {
        id,
        index,
        repHtml,
        words,
        minutes,
      },
    });
  });
};
```

### GatsbyのTypeScript化

GatsbyのTypeScript化は2021年の年末に実施しました。

TypeScript化の前に依存ライブラリの都合上Gatsby自体のバージョンアップ(v2=>v4)を先にしないといけない状況で、結構苦労した記憶があり本当はちゃんと記事を書きたかったのですが、もうすべてを忘れてしまいました。

今ではTypeScriptの型を存分に享受してます！

特にGatsbyのTypeScript化で苦労するところはMaybe型の扱いだと思います。

基本的に[gatsby-plugin-typegen](https://www.gatsbyjs.com/plugins/gatsby-plugin-typegen/)がGraphQLのスキーマーから型を自動生成してくれるのですが、その際の型がほとんどMaybe型といういわゆるundefinedが返る可能性を示すものとなります。

型生成としては正しいですが、これがReactだと扱いにくく、JavaScriptのときには一切なかった論理和(||)によるundefinedの回避や[Optional chaining](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Optional_chaining)をひたすら書かないといけません。

```typescript
// こんな感じのMaybeまつり
type MarkdownRemarkFrontmatter = {
  readonly title: Maybe<Scalars['String']>;
  readonly slug: Maybe<Scalars['String']>;
  readonly date: Maybe<Scalars['Date']>;
  readonly description: Maybe<Scalars['String']>;
  readonly tags: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly headerImage: Maybe<Scalars['String']>;
  readonly templateKey: Maybe<Scalars['String']>;
  readonly id: Maybe<Scalars['String']>;
};
```

Gatsbyを途中でTypeScript化しようと思っている人はOptional chainingに慣れておきましょう！まじで...。

### Preactの導入

ブログをGatsbyで作り始めて1年位たったあたりで爆速という触れ込みのGatsbyなのにやたら重たいサイトになってしまったという苦い経験があり、なんとなくReact=>Preactへの切り替えを実施した記憶があります。

こちらは[プラグインの指示通り](https://www.gatsbyjs.com/plugins/gatsby-plugin-preact/)入れればすんなり動いた感じで特に苦労しませんでした。

おそらくですが、複雑な遅延処理やstateの管理、useEffectのような副作用をやらないサイトで[preact/compat](https://www.npmjs.com/package/@preact/compat)を使わないで実装しきれたからだと思います。

効果は結構あって、[gatsby-plugin-webpack-bundle-analyser-v2](https://www.gatsbyjs.com/plugins/gatsby-plugin-webpack-bundle-analyser-v2/)でバンドルサイズを比較して1MB以上の削減効果があった(らしいです)

らしい、というのは当時のTwitterは過去つぶやきを掘り返されることによる炎上を防ぐ対策の一環で作った[tw-del-backup](https://github.com/tubone24/tw-del-backup)が綺麗サッパリ消していて、暗号化してバックアップされているつぶやきを見る限り、1MB以上削減できたということです。

![preact twitter]([https://i.imgur.com/Pb4nL6Ql.png)

tw-del-backupは定期的にTweetのバックアップと削除を行なう便利ツールですが、画像も容赦なく消してしまうのがまずいですね。画像も暗号化して保存するように作り直そうかしら...。

詳しくはCI/CD編でお話しようかと思うのですが、現在のProductionバンドルサイズは<https://tubone24.github.io/blog/ba/index.HTML>にホスティングするようにしているのでいつでも確認可能なのですが、

Parsedで1.35MB、GZip圧縮で343KBなのでやや重いですが、まぁ妥当な数字ではないでしょうか？(内半分は[Gitalk](https://github.com/gitalk/gitalk)というコメント管理のライブラリです。)

### CSSフレームワークとしてのBootstrapとSass with CSS Modules

このブログのスタイル周りはBootstrapがベースとなってます。

Why?という感じかもしれませんが、このブログのテンプレートつまり `Gaysby new` コマンドを実行した際にできるテンプレートがBootstrap v3ベースだったことと、当時Bootstrap以外のCSSフレームワークはmaterial UIしか知らず、冒険するのもなぁ〜という感じでBootstrapをそのまま使うことにしました。

実はこの判断が大失敗で、前述したTypeScript化の際にGatsbyのバージョンをv2からv4に上げる対応で、Bootstrap v3で使うJQueryとCSSのloadタイミングが狂ってしまい、実にツライことになりました。

なので、先にBootstrapがJQueryを使わなくなるBootstrap v5へのバージョンアップを済ませてから各ライブラリのバージョンアップを行い、TypeScript化したよ、という大工事を強いられたのです。

Bootstrap v5にアップデートするのではなく、別のCSSフレームワーク、例えばTailwindなどへの切り替えも検討していたのですが、モバイル対応のため採用していたGridシステムの置き換えが想像以上に大変だったことと、今のデザインを大きく変えたくなく、Bootstrapのほうが逆に古臭くて好きなのでいいかなと思ってBootstrapを使い続けることにしてます。

Daisy UIとか、tailwind-gridとかいろんな技術を触ってみましたがいずれしっくりこなかった、というより技術力がなくて使いこなせませんでした。

Bootstrapの置き換えなどは[今年も最後だからBlogのBootstrap v3を何とかする](https://blog.tubone-project24.xyz/2021/12/31/blog-bootstrap)に詳細があります。

細かいスタイルの調整にはSass(Scss)を使ってます。これも`Gaysby new` コマンドを実行した際にできるテンプレートで採用されていたこととCSS風ならとっつき安いかなという安易な考えで採用しました。

最初の頃はSassがグローバルに当たる構造だったので、BEMっぽくクラス名をつけてましたが、個人開発ではそんなルールはいずれ崩壊し、改修不可能なところまで汚染しまくっていたのでBootstrap v5化が終わったタイミングで思い切ってCSS Modulesに移行しました。

会社ではStyled-componentsを使ってますが、CSSに弱い私的にはCSSはCSSで別れたファイルの方がIDEでの補完がききやすく個人的には満足してます。

### Tailwindへの憧れはPurgeCSSで解決しろ！

とはいえ、流行っているTailwindへの憧れを捨てきれずにいた私は、どうしてBootstrapではなくTailwindを使いたいのかをあらためて自分に問いかけました。

色々考えた結果、Purge CSSくらいしか思いつかなかったので、BootstrapでもPurge CSSできるようにgatsby-plugin-purgecssを使いました。

ちょっとかっこ悪いですが、GlobalのScssにBootstrapのCSSをimportすることでBuild時に巨大なCSSを作り、そいつをPurgeさせてます。

```
gatsby-plugin-purgecss:
 Previous CSS Size: 237.61 KB
 New CSS Size: 57.13 KB (-75.96%)
 Removed ~180.48 KB of CSS
```

という結果がBuild時でるので、76%くらいは削れているっぽいです。優秀。

さらに、Scssで定義しているCSS Modulesもできるだけ小さくするべく、こちらはgatsby-plugin-minify-classnamesを使ってます。

Scss時点では

```scss
.container {
  display: flex;
}

.footer {
  padding: 1rem;
}
```

といったスタイルがCSSになると、

```css
/* index.module.css */

.b_b {
  display: flex;
}

.b_c {
  padding: 1rem;
}
```

といった感じでClass名がちっちゃくなります。これでどれくらいサイズが小さくなっているのかは不明ですが、自己満足の世界だと思います。

### Gatsby嫌なところ

これはいいところの相反ですが、やはりGraphQLを否応がなく意識させられます。それもGatsbyのプラグインシステムが作ったスキーマーを正しく理解することが求められます。

言い方かもしれませんが、GraphQLの知識は求められるのにGraphQLが使いこなせるようにはならない感覚に近いです。なので、GraphQLが〜という理由一点張りで採用することはあまりおすすめできないなというのが私の所管です。

あと、プラグインが便利すぎて使いまくっているのですが、結構動作原理がわかりにくいです。プラグイン同士の競合もめっちゃします。そのデバッグは骨が折れるので、ちゃんとコードが書ける人はスクラッチしたほうが無駄な時間を過ごさなそうです。

一例ですが、gatsby-plugin-typegenとgatsby-source-filesystemみたいに、コード自動生成系のプラグインとデータソースのプラグインはお互いの処理をトリガーに処理が走る可能性があるので処理がループしがちです。こういったところを解きほぐしていくのはプラグインでサクサク実装したい思想から外れてしまう動きなのかもしれませんね..。
