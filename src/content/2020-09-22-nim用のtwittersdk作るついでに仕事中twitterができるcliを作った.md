---
slug: 2020/09/22/nim-twitter
title: Nim用のTwitterSDK作るついでに仕事中TwitterができるCLIを作った
date: 2020-09-22T11:39:58.035Z
description: Nim用のTwitterSDK作るついでに仕事中TwitterができるCLIを作った
tags:
  - Nim
  - Twitter
headerImage: https://i.imgur.com/BO7QR6p.png
templateKey: blog-post
---
NimのTwitterSDKを作ってOSS兄貴になろうと思ったら、結局なれませんでした。


## Table of Contents

```toc

```

## Nimとは？

詳しくは[docoptはNimでも使えたのお話
](https://blog.tubone-project24.xyz/2019/11/20/docopt-nim#%E3%81%9D%E3%82%82%E3%81%9D%E3%82%82nim%E3%81%A8%E3%81%AF%EF%BC%9F)をご覧いただければと思いますが、**静的型付なコンパイラ言語**でPython, Ada, modulaなどの成熟した言語のいいとこ取りをした**能率的**で、**表現力豊か**で、**エレガントな言語**です。

![img](https://i.imgur.com/BbHTNwQ.png)

いわゆる別言語へのトランスパイルを通して、ビルドする言語となり、通常はCを使いますが、C++、JavaScript、Javaなんかへの変換が可能です。(フロントとバックエンドと両方の言語としての覇権を狙っている！？)

言語の構文もPythonのそれに近く、さらに言えば実行速度も早く、GoのようにArtifactsが巨大になることもありません。

ここまで聞くと、いいこと尽くめで素晴らしいのですがNimには欠点があります。

それは悲しいくらい**流行ってない**ということです。

いや、一部の熱狂的信者はいるのですが一般的か？と言われると疑問符がついてしまうのです。

## どうして流行らないのか？

これはあくまでも私の主観なのですが、おそらく

**Pythonの皮を被ったC言語というのは所詮C言語でしかない**というところでしょうか？

例えば新しい言語でV言語というのがありますが、あちらは**Go**の構文を色濃く採用しながら、Goのイケてないところ、ジェネリクス(Go2では採用されるらしいですが)やアクセス修飾子、ワンバイナリからlibの切り出しRustに代表されるGCを使わないメモリ管理などを組み込んでいます。

V言語も流行っているわけではないが、Nimよりは周りで聞くような**気**もします。あくまでも気もするだけだが...。

V言語はGoを参考にした構文に対し、NimはPythonを明らかに参考にしています。それだけ、書きやすいのかな？と思いつつ例えばこんなことが起きます。

```nim
proc hoge(n: int): int

proc fuga(n: int): int =
  result = hoge(n) + 1

proc hoge(n: int): int =
  return 2 ^ n
```

C言語に親しみのある方は、一行目のhoge関数はプロトタイプ宣言かと思いますが、Python書いているだけだと、こんなことわかりません。

Nimを書いているとちょこちょここんなことが起きます。

型は型アノテーションもあったりするので慣れ親しんだ人もいると思いますが、C言語特有の話が出てくるとちょっと混乱したりします。

こういうところがPythonとデラ相性が悪いのです。(と感じるのです)

## NimでTwitterSDK作る

とまぁいろいろ問題点は書きましたが、私はNimが好きなので、何か貢献しようと思いTwitterSDKを作っていこうと思います。

マイナー言語は車輪の再開発の心配がなくものづくりができるのですばらしいですね。（涙）

ということでまず、TwitterAPIへのアクセス方法について確認します。

## oAuth1.0をNimで使うには？

APIを使うにはHTTPリクエストができないといけないですが、Nimにはhttpclientというライブラリがあらかじめ用意されております。

がしかしザンネンながら、NimのhttpclientはoAuthには対応してないので、処理系は自前で作らないといけません。

oAuth2.0、つまりapplication keyとそのシークレットでアクセス可能なAPIであればさほど処理系は難しくなく、Basic認証としてheaderにそれぞれを設定してあげればBearer tokenが取得できます。

コード

しかしながらoAuth1.0となると異なります。
